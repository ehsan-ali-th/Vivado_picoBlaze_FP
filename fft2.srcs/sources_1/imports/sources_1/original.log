KCPSM6 Assembler log file for program 'D:\workspace\Vivado_2018.3\zcu104\fft2\fft2.srcs\sources_1\imports\sources_1\original.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 14 Feb 2019
Assembly timestamp: 00:24:57

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 623 hex
Nominal program memory size: 2K (2048)   address(10:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 1572
Memory locations available: 2524


Assembly listing

 Addr Code                                      Instruction

 000                                            CONSTANT UART_Tx_data_present, 00000001'b
 000                                            CONSTANT UART_Tx_half_full, 00000010'b
 000                                            CONSTANT UART_Tx_full, 00000100'b
 000                                            CONSTANT UART_Rx_data_present, 00001000'b
 000                                            CONSTANT UART_Rx_half_full, 00010000'b
 000                                            CONSTANT UART_Rx_full, 00100000'b
 000                                            ; Input Ports
 000                                            CONSTANT UART_RX6_status_input_port, 00
 000                                            CONSTANT UART_RX6_data_input_port, 01
 000                                            CONSTANT Extra_mem_input_port, 02
 000                                            ; Output Ports
 000                                            CONSTANT UART_TX6_output_port, 00
 000                                            CONSTANT Extra_mem_lo_output_port, 01
 000                                            CONSTANT Extra_mem_hi_output_port, 02
 000                                            CONSTANT Extra_mem_output_port, 03
 000                                            CONSTANT irqs_output_port, 04
 000                                            CONSTANT reset_UART_port, 01
 000                                            CONSTANT UART_tx_reset, 00000001'b
 000                                            CONSTANT UART_rx_reset, 00000010'b
 000                                            CONSTANT UART_reset, 00000011'b
 000                                            ;reset Tx and Rx
 000                                            CONSTANT UART_operate, 00000000'b              ; Tx and Rx free to operate
 000                                            ; Scratch Pad Memory locations
 000                                            CONSTANT x_7, 0'd                              ; Do not change the decimal numbers or load into SPM will not work
 000                                            CONSTANT x_6, 1'd
 000                                            CONSTANT x_5, 2'd
 000                                            CONSTANT x_4, 3'd
 000                                            CONSTANT x_3, 4'd
 000                                            CONSTANT x_2, 5'd
 000                                            CONSTANT x_1, 6'd
 000                                            CONSTANT x_0, 7'd
 000                                            CONSTANT y_7, 8'd
 000                                            CONSTANT y_6, 9'd
 000                                            CONSTANT y_5, 10'd
 000                                            CONSTANT y_4, 11'd
 000                                            CONSTANT y_3, 12'd
 000                                            CONSTANT y_2, 13'd
 000                                            CONSTANT y_1, 14'd
 000                                            CONSTANT y_0, 15'd
 000                                            CONSTANT r_7, 16'd
 000                                            CONSTANT r_6, 17'd
 000                                            CONSTANT r_5, 18'd
 000                                            CONSTANT r_4, 19'd
 000                                            CONSTANT r_3, 20'd
 000                                            CONSTANT r_2, 21'd
 000                                            CONSTANT r_1, 22'd
 000                                            CONSTANT r_0, 23'd
 000                                            CONSTANT x_sign, 24'd                          ; positive = 0x00, negative = 0x80
 000                                            CONSTANT x_ex7, 25'd
 000                                            CONSTANT x_ex6, 26'd
 000                                            CONSTANT x_m6, 27'd
 000                                            CONSTANT x_m5, 28'd
 000                                            CONSTANT x_m4, 29'd
 000                                            CONSTANT x_m3, 30'd
 000                                            CONSTANT x_m2, 31'd
 000                                            CONSTANT x_m1, 32'd
 000                                            CONSTANT x_m0, 33'd
 000                                            CONSTANT x_grs, 34'd                           ; 8-bit: grs0_0000
 000                                            CONSTANT y_sign, 35'd                          ; positive = 0x00, negative = 0x80
 000                                            CONSTANT y_ex7, 36'd
 000                                            CONSTANT y_ex6, 37'd
 000                                            CONSTANT y_m6, 38'd
 000                                            CONSTANT y_m5, 39'd
 000                                            CONSTANT y_m4, 40'd
 000                                            CONSTANT y_m3, 41'd
 000                                            CONSTANT y_m2, 42'd
 000                                            CONSTANT y_m1, 43'd
 000                                            CONSTANT y_m0, 44'd
 000                                            CONSTANT y_grs, 45'd                           ; 8-bit: grs0_0000
 000                                            CONSTANT r_sign, 46'd                          ; positive = 0x00, negative = 0x80
 000                                            CONSTANT r_ex7, 47'd
 000                                            CONSTANT r_ex6, 48'd
 000                                            CONSTANT r_m6, 49'd
 000                                            CONSTANT r_m5, 50'd
 000                                            CONSTANT r_m4, 51'd
 000                                            CONSTANT r_m3, 52'd
 000                                            CONSTANT r_m2, 53'd
 000                                            CONSTANT r_m1, 55'd
 000                                            CONSTANT r_m0, 56'd
 000                                            CONSTANT r_grs, 57'd                           ; 8-bit: grs0_0000
 000                                            ;----------------------------------------------------------------
 000                                            ; If a bit is 0 = no, 1 = yes
 000                                            ;
 000                                            ; Bit 7   6 5 4 3 2 1 0
 000                                            ;     |   | | |             |
 000                                            ;     |   | | |             [ Normal
 000                                            ;     |   | | [ NaN
 000                                            ;     |   | [ Infinite
 000                                            ;     |   [ Zero
 000                                            ;     [ Subnormal
 000                                            ;
 000                                            ;
 000                                            ; An operand can have one of the following statuses:
 000                                            ; 1)  Normal
 000                                            ; 2) Subnormal
 000                                            ; 3)  Zero +/-
 000                                            ; 4)  Infinit +/-
 000                                            ; 5)  NaN
 000                                            ;---------------------------------------------------------------
 000                                            CONSTANT op1_status, 58'd
 000                                            CONSTANT op2_status, 59'd
 000                                            CONSTANT underflow, 60'd                       ; underflow not applied = 0x00, underflow applied = 0x01
 000                                            ;----------------------------------------------------------------
 000                                            ; Bit 7   6  5 4 3 2 1 0
 000                                            ;     |   |  | | |
 000                                            ;     |   |  | | [Inexact
 000                                            ;     |   |  | [Underflow
 000                                            ;     |   |  [Overflow
 000                                            ;     |   [Division by zero
 000                                            ;     [Invalid Opration: Quite Not A Nuber (qNaN)
 000                                            ;
 000                                            ;
 000                                            ;---------------------------------------------------------------
 000                                            CONSTANT IEEE_754_DP_signals, 61'd
 000                                            CONSTANT Umr_6, 64'd                           ; 0x40 only two bits on right is used : 0b----_--XX
 000                                            CONSTANT Umr_5, 65'd
 000                                            CONSTANT Umr_4, 66'd
 000                                            CONSTANT Umr_3, 67'd
 000                                            CONSTANT Umr_2, 68'd
 000                                            CONSTANT Umr_1, 69'd
 000                                            CONSTANT Umr_0, 70'd
 000                                            CONSTANT Lmr_6, 71'd
 000                                            CONSTANT Lmr_5, 72'd
 000                                            CONSTANT Lmr_4, 73'd
 000                                            CONSTANT Lmr_3, 74'd
 000                                            CONSTANT Lmr_2, 75'd
 000                                            CONSTANT Lmr_1, 76'd
 000                                            CONSTANT Lmr_0, 77'd                           ; 0x4D
 000                                            CONSTANT mr_save_carry, 78'd                   ; 0x4E   0x00 = no carry, 0x01 = carry
 000                                            CONSTANT Umx_shifted_6, 80'd                   ; 0x50
 000                                            CONSTANT Umx_shifted_5, 81'd
 000                                            CONSTANT Umx_shifted_4, 82'd
 000                                            CONSTANT Umx_shifted_3, 83'd
 000                                            CONSTANT Umx_shifted_2, 84'd
 000                                            CONSTANT Umx_shifted_1, 85'd
 000                                            CONSTANT Umx_shifted_0, 86'd
 000                                            CONSTANT Lmx_shifted_6, 87'd
 000                                            CONSTANT Lmx_shifted_5, 88'd
 000                                            CONSTANT Lmx_shifted_4, 89'd
 000                                            CONSTANT Lmx_shifted_3, 90'd
 000                                            CONSTANT Lmx_shifted_2, 91'd
 000                                            CONSTANT Lmx_shifted_1, 92'd
 000                                            CONSTANT Lmx_shifted_0, 93'd                   ; 0x5D
 000  22004                                     JUMP 004[start]
 001  22004                                     JUMP 004[start]
 002  22004                                     JUMP 004[start]
 003  22004                                     JUMP 004[start]
 004                                     start: 
 004  2008B                                     CALL 08B[reset_UART_macros]
 005                                            ;      JUMP uart_loop
 005  01600                                     LOAD s6, 00                                    ; Start at address [s6,s5] = 0x000
 006  01500                                     LOAD s5, 00
 007  01800                                     LOAD s8, 00[x_7]                               ; Save at starting point = x_7
 008  200E3                                     CALL 0E3[load_8Bytes_from_ext_BRAM]
 009  01600                                     LOAD s6, 00                                    ; Start at address [s6,s5] = 0x008
 00A  01508                                     LOAD s5, 08
 00B  01808                                     LOAD s8, 08[y_7]                               ; Save at starting point = y_7
 00C  200E3                                     CALL 0E3[load_8Bytes_from_ext_BRAM]
 00D                                            ; Clear the operand status, as the SPM holds its previous values
 00D                                            ;  even after picoBlaze gets reset.
 00D  01000                                     LOAD s0, 00
 00E  2F022                                     STORE s0, 22[x_grs]
 00F  2F02D                                     STORE s0, 2D[y_grs]
 010  2F039                                     STORE s0, 39[r_grs]
 011  2F02E                                     STORE s0, 2E[r_sign]
 012  2F03A                                     STORE s0, 3A[op1_status]
 013  2F03B                                     STORE s0, 3B[op2_status]
 014  2F03C                                     STORE s0, 3C[underflow]
 015  2F040                                     STORE s0, 40[Umr_6]
 016  2F041                                     STORE s0, 41[Umr_5]
 017  2F042                                     STORE s0, 42[Umr_4]
 018  2F043                                     STORE s0, 43[Umr_3]
 019  2F044                                     STORE s0, 44[Umr_2]
 01A  2F045                                     STORE s0, 45[Umr_1]
 01B  2F046                                     STORE s0, 46[Umr_0]
 01C  2F047                                     STORE s0, 47[Lmr_6]
 01D  2F048                                     STORE s0, 48[Lmr_5]
 01E  2F049                                     STORE s0, 49[Lmr_4]
 01F  2F04A                                     STORE s0, 4A[Lmr_3]
 020  2F04B                                     STORE s0, 4B[Lmr_2]
 021  2F04C                                     STORE s0, 4C[Lmr_1]
 022  2F04D                                     STORE s0, 4D[Lmr_0]
 023  2F04E                                     STORE s0, 4E[mr_save_carry]
 024  2F050                                     STORE s0, 50[Umx_shifted_6]
 025  2F051                                     STORE s0, 51[Umx_shifted_5]
 026  2F052                                     STORE s0, 52[Umx_shifted_4]
 027  2F053                                     STORE s0, 53[Umx_shifted_3]
 028  2F054                                     STORE s0, 54[Umx_shifted_2]
 029  2F055                                     STORE s0, 55[Umx_shifted_1]
 02A  2F056                                     STORE s0, 56[Umx_shifted_0]
 02B  2F057                                     STORE s0, 57[Lmx_shifted_6]
 02C  2F058                                     STORE s0, 58[Lmx_shifted_5]
 02D  2F059                                     STORE s0, 59[Lmx_shifted_4]
 02E  2F05A                                     STORE s0, 5A[Lmx_shifted_3]
 02F  2F05B                                     STORE s0, 5B[Lmx_shifted_2]
 030  2F05C                                     STORE s0, 5C[Lmx_shifted_1]
 031  2F05D                                     STORE s0, 5D[Lmx_shifted_0]
 032                                            ; Load configuration at address 0xFFC
 032  015FC                                     LOAD s5, FC
 033  0160F                                     LOAD s6, 0F
 034  200ED                                     CALL 0ED[Read_ext_mem]                         ; config byte will be  returned in s7
 035  0D701                                     TEST s7, 01
 036  3603B                                     JUMP NZ, 03B[debug_mode]
 037                                            ;       CALL  arith_add_x_y
 037  2048E                                     CALL 48E[arith_mul_x_y]
 038  20108                                     CALL 108[write_result_to_external_memory]
 039  200FD                                     CALL 0FD[invoke_done_interrupt]
 03A                      finished_calculation: 
 03A  2203A                                     JUMP 03A[finished_calculation]
 03B                                debug_mode: 
 03B  200A0                                     CALL 0A0[clear_screen]
 03C                                            ;       CALL  arith_add_x_y
 03C  2048E                                     CALL 48E[arith_mul_x_y]
 03D  20108                                     CALL 108[write_result_to_external_memory]
 03E  01B00                                     LOAD sB, 00[welcome_msg'upper]                 ;Display message
 03F  01A53                                     LOAD sA, 53[welcome_msg'lower]
 040  20099                                     CALL 099[send_message]
 041  20094                                     CALL 094[send_CRLF]
 042                        print_two_operands: 
 042  01900                                     LOAD s9, 00[x_7]
 043  200C5                                     CALL 0C5[SPM_print_hex]
 044  20094                                     CALL 094[send_CRLF]
 045  01908                                     LOAD s9, 08[y_7]
 046  200C5                                     CALL 0C5[SPM_print_hex]
 047  20094                                     CALL 094[send_CRLF]
 048  01910                                     LOAD s9, 10[r_7]
 049  200C5                                     CALL 0C5[SPM_print_hex]
 04A  20094                                     CALL 094[send_CRLF]
 04B  200FD                                     CALL 0FD[invoke_done_interrupt]
 04C                            wait_for_start: 
 04C  20082                                     CALL 082[UART_RX]
 04D  3204C                                     JUMP Z, 04C[wait_for_start]                    ;check for UART timeout
 04E  1D553                                     COMPARE s5, 53["S"]                            ;test character received
 04F  32042                                     JUMP Z, 042[print_two_operands]
 050  1D573                                     COMPARE s5, 73["s"]
 051  3604C                                     JUMP NZ, 04C[wait_for_start]
 052  22042                                     JUMP 042[print_two_operands]
 053                                            STRING welcome$, "Welcome to KCPSM6 !!! (Debug Mode)"
 053                               welcome_msg: 
 053  2150D                                     LOAD&RETURN s5, 0D[CR]
 054  2150A                                     LOAD&RETURN s5, 0A[LF]
 055  21557                                     LOAD&RETURN s5, 57[welcome$:"W"]
 056  21565                                     LOAD&RETURN s5, 65[welcome$:"e"]
 057  2156C                                     LOAD&RETURN s5, 6C[welcome$:"l"]
 058  21563                                     LOAD&RETURN s5, 63[welcome$:"c"]
 059  2156F                                     LOAD&RETURN s5, 6F[welcome$:"o"]
 05A  2156D                                     LOAD&RETURN s5, 6D[welcome$:"m"]
 05B  21565                                     LOAD&RETURN s5, 65[welcome$:"e"]
 05C  21520                                     LOAD&RETURN s5, 20[welcome$:" "]
 05D  21574                                     LOAD&RETURN s5, 74[welcome$:"t"]
 05E  2156F                                     LOAD&RETURN s5, 6F[welcome$:"o"]
 05F  21520                                     LOAD&RETURN s5, 20[welcome$:" "]
 060  2154B                                     LOAD&RETURN s5, 4B[welcome$:"K"]
 061  21543                                     LOAD&RETURN s5, 43[welcome$:"C"]
 062  21550                                     LOAD&RETURN s5, 50[welcome$:"P"]
 063  21553                                     LOAD&RETURN s5, 53[welcome$:"S"]
 064  2154D                                     LOAD&RETURN s5, 4D[welcome$:"M"]
 065  21536                                     LOAD&RETURN s5, 36[welcome$:"6"]
 066  21520                                     LOAD&RETURN s5, 20[welcome$:" "]
 067  21521                                     LOAD&RETURN s5, 21[welcome$:"!"]
 068  21521                                     LOAD&RETURN s5, 21[welcome$:"!"]
 069  21521                                     LOAD&RETURN s5, 21[welcome$:"!"]
 06A  21520                                     LOAD&RETURN s5, 20[welcome$:" "]
 06B  21528                                     LOAD&RETURN s5, 28[welcome$:"("]
 06C  21544                                     LOAD&RETURN s5, 44[welcome$:"D"]
 06D  21565                                     LOAD&RETURN s5, 65[welcome$:"e"]
 06E  21562                                     LOAD&RETURN s5, 62[welcome$:"b"]
 06F  21575                                     LOAD&RETURN s5, 75[welcome$:"u"]
 070  21567                                     LOAD&RETURN s5, 67[welcome$:"g"]
 071  21520                                     LOAD&RETURN s5, 20[welcome$:" "]
 072  2154D                                     LOAD&RETURN s5, 4D[welcome$:"M"]
 073  2156F                                     LOAD&RETURN s5, 6F[welcome$:"o"]
 074  21564                                     LOAD&RETURN s5, 64[welcome$:"d"]
 075  21565                                     LOAD&RETURN s5, 65[welcome$:"e"]
 076  21529                                     LOAD&RETURN s5, 29[welcome$:")"]
 077  21500                                     LOAD&RETURN s5, 00[NUL]
 078                                            ;------------------------------------------------------------------------------------
 078                                            ; Procedure:  UART_TX()
 078                                            ; Registers Used:
 078                                            ;        Bank0 : s6 , s5
 078                                            ;   Bank1 : None
 078                                            ;
 078                                            ; Arguments:
 078                                            ;    Bank0 : None
 078                                            ;   Bank1 : None
 078                                            ;
 078                                            ; Calls:  delay_1ms
 078                                            ;
 078                                            ; Returns:  None
 078                                            ;
 078                                            ; Return Flags:  None
 078                                            ;
 078                                            ; Description:  Routine to send one character to the UART Transmitter (UART_TX6)
 078                                            ;
 078                                            ; This routine will transmit the character provided in register 's5'.
 078                                            ;------------------------------------------------------------------------------------
 078                                   UART_TX: 
 078  09600                                     INPUT s6, 00[UART_RX6_status_input_port]
 079  0D604                                     TEST s6, 04[UART_Tx_full]
 07A  36078                                     JUMP NZ, 078[UART_TX]
 07B  2D500                                     OUTPUT s5, 00[UART_TX6_output_port]
 07C                                            ; We need a bit of delay here: 10240 cycles : 2800 hex
 07C                                            ; ((6 x 1us_delay_count]) + 8) clock cycles.
 07C                                            ;   ; 100Mhz => 1us = 100,000 cycles
 07C                                            ;    We need 16,665 cycles = 4119 hex
 07C  01519                                     LOAD s5, 19
 07D  01641                                     LOAD s6, 41
 07E                             UART_TX_delay: 
 07E  19501                                     SUB s5, 01
 07F  1B600                                     SUBCY s6, 00
 080  3607E                                     JUMP NZ, 07E[UART_TX_delay]
 081  25000                                     RETURN 
 082                                            ;------------------------------------------------------------------------------------
 082                                            ; Procedure:  UART_RX()
 082                                            ; Registers Used:
 082                                            ;        Bank0 : s7, s6 , s5
 082                                            ;   Bank1 : None
 082                                            ;
 082                                            ; Arguments:
 082                                            ;    Bank0 : None
 082                                            ;   Bank1 : None
 082                                            ;
 082                                            ; Calls:  None
 082                                            ;
 082                                            ; Returns:  s5 (character read)
 082                                            ;
 082                                            ; Return Flags:  Zero flag will be reset (Z=0) if read is successful.
 082                                            ;
 082                                            ; Description:  Routine to attempt to receive one character from the UART
 082                                            ;    Receiver 'uart_rx6'.
 082                                            ;
 082                                            ; This routine will attempt to receive one character from the 'UART_RX6' macro, and if
 082                                            ; successful, will return that character in register 's5' and the Zero flag will be
 082                                            ; reset (Z=0).
 082                                            ;
 082                                            ; If there are no characters available to be read from the FIFO buffer within the
 082                                            ; 'UART_RX6' macro then this routine will timeout after ~2,000 clock cycles (which is
 082                                            ; 40us at 50MHz) with the Zero flag set (Z=1). This timeout scheme ensures that KCPSM6
 082                                            ; cannot become stuck in this routine if no characters are received. If you do want
 082                                            ; KCPSM6 to wait indefinitely for a character to be received then either modify this
 082                                            ; routine or perform a test of the Zero flag and repeat the call to this routine as
 082                                            ; shown in this example...
 082                                            ;
 082                                            ;          wait_for_UART_RX: CALL UART_RX
 082                                            ;                            JUMP Z, wait_for_UART_RX
 082                                            ;------------------------------------------------------------------------------------
 082                                   UART_RX: 
 082  017A7                                     LOAD s7, A7[167'd]                             ;Timeout =
 083                                            ;167 x (6 instructions x 2 clock cycles)
 083                                rx_timeout: 
 083  09600                                     INPUT s6, 00[UART_RX6_status_input_port]
 084  0D608                                     TEST s6, 08[UART_Rx_data_present]              ;Z=0 and C=1 when data present
 085  36089                                     JUMP NZ, 089[read_Rx]
 086  19701                                     SUB s7, 01[1'd]
 087  31000                                     RETURN Z                                       ;Timeout returns with Z=1 and C=0
 088  22083                                     JUMP 083[rx_timeout]
 089  09501                            read_Rx: INPUT s5, 01[UART_RX6_data_input_port]         ;read character from buffer
 08A  25000                                     RETURN 
 08B                                            ;------------------------------------------------------------------------------------
 08B                                            ; Procedure:  reset_UART_macros()
 08B                                            ; Registers Used:
 08B                                            ;        Bank0 : None
 08B                                            ;   Bank1 : None
 08B                                            ;
 08B                                            ; Arguments:
 08B                                            ;    Bank0 : None
 08B                                            ;   Bank1 : None
 08B                                            ;
 08B                                            ; Calls:  None
 08B                                            ;
 08B                                            ;
 08B                                            ; Description:  Resets UART.
 08B                                            ;
 08B                                            ;------------------------------------------------------------------------------------
 08B                         reset_UART_macros: 
 08B  2B031                                     OUTPUTK 03[UART_reset], 1[reset_UART_port]
 08C  2B001                                     OUTPUTK 00[UART_operate], 1[reset_UART_port]
 08D  25000                                     RETURN 
 08E                                            ;------------------------------------------------------------------------------------
 08E                                            ; Procedure:  delay_1ms()
 08E                                            ; Registers Used:
 08E                                            ;        Bank0 : s7, s6
 08E                                            ;   Bank1 : None
 08E                                            ;
 08E                                            ; Arguments:
 08E                                            ;    Bank0 : None
 08E                                            ;   Bank1 : None
 08E                                            ;
 08E                                            ; Calls:  None
 08E                                            ;
 08E                                            ;
 08E                                            ; Description:  1ms delay.
 08E                                            ;
 08E                                            ;   ((6 x 1ms_delay_count1]) + 8) clock cycles.
 08E                                            ;   ; 125Mhz => 1ms = 125,000 cycles
 08E                                            ;    We need 20,832 cycles = 5160 hex
 08E                                            ;------------------------------------------------------------------------------------
 08E                                 delay_1ms: 
 08E  01660                                     LOAD s6, 60
 08F  01751                                     LOAD s7, 51
 090                            delay_1ms_loop: 
 090  19601                                     SUB s6, 01
 091  1B700                                     SUBCY s7, 00
 092  36090                                     JUMP NZ, 090[delay_1ms_loop]
 093  25000                                     RETURN 
 094                                            ;------------------------------------------------------------------------------------
 094                                            ; Procedure:  send_CRLF()
 094                                            ; Registers Used:
 094                                            ;        Bank0 : s5
 094                                            ;   Bank1 : None
 094                                            ;
 094                                            ; Arguments:
 094                                            ;    Bank0 : None
 094                                            ;   Bank1 : None
 094                                            ;
 094                                            ; Calls:  UART_TX()
 094                                            ;
 094                                            ;
 094                                            ; Description:  Sends a CRLF to the UART.
 094                                            ;
 094                                            ;------------------------------------------------------------------------------------
 094                                 send_CRLF: 
 094  0150D                                     LOAD s5, 0D[CR]
 095  20078                                     CALL 078[UART_TX]
 096  0150A                                     LOAD s5, 0A[LF]
 097  20078                                     CALL 078[UART_TX]
 098  25000                                     RETURN 
 099                                            ;------------------------------------------------------------------------------------
 099                                            ; Procedure:  send_message()
 099                                            ; Registers Used:
 099                                            ;        Bank0 : s5, sA, sB
 099                                            ;   Bank1 : None
 099                                            ;
 099                                            ; Arguments:
 099                                            ;    Bank0 : None
 099                                            ;   Bank1 : None
 099                                            ;
 099                                            ; Calls:  UART_TX()
 099                                            ;
 099                                            ;
 099                                            ; Description:  Sends a message to the UART.
 099                                            ;
 099                                            ;   The start address of the message must be provided in [sB,sA].
 099                                            ;    Terminate the transmission with a NULL character (00 hex).
 099                                            ;------------------------------------------------------------------------------------
 099                              send_message: 
 099  24BA0                                     CALL@ (sB, sA)
 09A  1D500                                     COMPARE s5, 00                                 ;terminate on NUL character
 09B  31000                                     RETURN Z
 09C  20078                                     CALL 078[UART_TX]
 09D  11A01                                     ADD sA, 01[1'd]
 09E  13B00                                     ADDCY sB, 00[0'd]
 09F  22099                                     JUMP 099[send_message]
 0A0                                            ;------------------------------------------------------------------------------------
 0A0                                            ; Procedure:  clear_screen()
 0A0                                            ; Registers Used:
 0A0                                            ;        Bank0 : s5
 0A0                                            ;   Bank1 : None
 0A0                                            ;
 0A0                                            ; Arguments:
 0A0                                            ;    Bank0 : None
 0A0                                            ;   Bank1 : None
 0A0                                            ;
 0A0                                            ; Calls:  UART_TX()
 0A0                                            ;
 0A0                                            ; Description:  Clears the UART screen.
 0A0                                            ;------------------------------------------------------------------------------------
 0A0                              clear_screen: 
 0A0  0151B                                     LOAD s5, 1B[ESC]                               ;clear terminal sequence
 0A1  20078                                     CALL 078[UART_TX]
 0A2  0155B                                     LOAD s5, 5B["["]
 0A3  20078                                     CALL 078[UART_TX]
 0A4  01532                                     LOAD s5, 32["2"]
 0A5  20078                                     CALL 078[UART_TX]
 0A6  0154A                                     LOAD s5, 4A["J"]
 0A7  20078                                     CALL 078[UART_TX]
 0A8  0151B                                     LOAD s5, 1B[ESC]
 0A9  20078                                     CALL 078[UART_TX]
 0AA  0155B                                     LOAD s5, 5B["["]
 0AB  20078                                     CALL 078[UART_TX]
 0AC  01548                                     LOAD s5, 48["H"]
 0AD  20078                                     CALL 078[UART_TX]
 0AE  25000                                     RETURN 
 0AF                                            ;------------------------------------------------------------------------------------
 0AF                                            ; Procedure:  print_hex_from_table()
 0AF                                            ; Registers Used:
 0AF                                            ;        Bank0 : sB, sA, s8, s7 , s5
 0AF                                            ;   Bank1 : None
 0AF                                            ;
 0AF                                            ; Arguments:
 0AF                                            ;    Bank0 : [sB, sA] :Message upper/lower address
 0AF                                            ;   Bank1 : None
 0AF                                            ;
 0AF                                            ; Calls:  UART_TX (s6, s5)
 0AF                                            ;
 0AF                                            ; Returns:  None
 0AF                                            ;
 0AF                                            ; Return Flags:  None
 0AF                                            ;
 0AF                                            ; Description:  Prints a 64-bit double precision number.
 0AF                                            ;------------------------------------------------------------------------------------
 0AF                                            ; print_hex_from_table:
 0AF                                            ;  LOAD s8, 8'd  ; Double precision has 8 bytes
 0AF                                            ; print_hex_loop:
 0AF                                            ;  CALL@ (sB, sA)  ; read the first byte in s5
 0AF                                            ;  LOAD s7, s5  ; Copy s5
 0AF                                            ;  SR0 s5      ; shift the 4 bit on he left to the right
 0AF                                            ;  SR0 s5
 0AF                                            ;  SR0 s5
 0AF                                            ;  SR0 s5
 0AF                                            ;  COMPARE s5, 10'd
 0AF                                            ;  JUMP C, less_or_eq_to_nine
 0AF                                            ;  JUMP greater_than_nine
 0AF                                            ; less_or_eq_to_nine:
 0AF                                            ;  ADD s5, 48'd
 0AF                                            ;  JUMP done_adding
 0AF                                            ; greater_than_nine:
 0AF                                            ;  ADD s5, 87'd
 0AF                                            ; done_adding:
 0AF                                            ;  CALL UART_TX  ; send it to UART via s5
 0AF                                            ;  ;--- Second nibble
 0AF                                            ;  AND s7, 0f   ; select the 4 bit on the right
 0AF                                            ;  COMPARE s7, 10'd
 0AF                                            ;  JUMP C, less_or_eq_to_nine2
 0AF                                            ;  JUMP greater_than_nine2
 0AF                                            ; less_or_eq_to_nine2:
 0AF                                            ;  ADD s7, 48'd
 0AF                                            ;  JUMP done_adding2
 0AF                                            ; greater_than_nine2:
 0AF                                            ;  ADD s7, 87'd
 0AF                                            ; done_adding2:
 0AF                                            ;  LOAD s5, s7
 0AF                                            ;  CALL UART_TX  ; send it to UART via s5
 0AF                                            ; done_print_one_hex:
 0AF                                            ;  ADD sA, 1'd  ; read the next byte
 0AF                                            ;  ADDCY sB, 0'd
 0AF                                            ;  SUB s8, 1'd  ; decrement the counter
 0AF                                            ;  TEST s8, FF  ; Is cunter zero?
 0AF                                            ;  RETURN Z
 0AF                                            ;  JUMP print_hex_loop
 0AF                                            ;  RETURN
 0AF                                            ;------------------------------------------------------------------------------------
 0AF                                            ; Procedure:  reg_print_hex()
 0AF                                            ; Registers Used:
 0AF                                            ;        Bank0 : s5, s7
 0AF                                            ;   Bank1 : None
 0AF                                            ;
 0AF                                            ; Arguments:
 0AF                                            ;    Bank0 : s5 : content to print
 0AF                                            ;   Bank1 : None
 0AF                                            ;
 0AF                                            ; Calls:  UART_TX
 0AF                                            ;
 0AF                                            ; Returns:  None
 0AF                                            ;
 0AF                                            ; Return Flags:  None
 0AF                                            ;
 0AF                                            ; Description:  Prints an 8-bit number stored in s5 in hex formatx
 0AF                                            ;------------------------------------------------------------------------------------
 0AF                             reg_print_hex: 
 0AF  00750                                     LOAD s7, s5                                    ; Copy s5
 0B0  1450E                                     SR0 s5                                         ; shift the 4 bit on the left to the right
 0B1  1450E                                     SR0 s5
 0B2  1450E                                     SR0 s5
 0B3  1450E                                     SR0 s5
 0B4  1D50A                                     COMPARE s5, 0A[10'd]
 0B5  3A0B7                                     JUMP C, 0B7[less_or_eq_to_nine3]
 0B6  220B9                                     JUMP 0B9[greater_than_nine3]
 0B7                       less_or_eq_to_nine3: 
 0B7  11530                                     ADD s5, 30[48'd]
 0B8  220BA                                     JUMP 0BA[done_adding3]
 0B9                        greater_than_nine3: 
 0B9  11557                                     ADD s5, 57[87'd]
 0BA                              done_adding3: 
 0BA  20078                                     CALL 078[UART_TX]                              ; send it to UART via s5
 0BB                                            ;--- Second nibble
 0BB  0370F                                     AND s7, 0F                                     ; select the 4 bit on the right
 0BC  1D70A                                     COMPARE s7, 0A[10'd]
 0BD  3A0BF                                     JUMP C, 0BF[less_or_eq_to_nine4]
 0BE  220C1                                     JUMP 0C1[greater_than_nine4]
 0BF                       less_or_eq_to_nine4: 
 0BF  11730                                     ADD s7, 30[48'd]
 0C0  220C2                                     JUMP 0C2[done_adding4]
 0C1                        greater_than_nine4: 
 0C1  11757                                     ADD s7, 57[87'd]
 0C2                              done_adding4: 
 0C2  00570                                     LOAD s5, s7
 0C3  20078                                     CALL 078[UART_TX]                              ; send it to UART via s5
 0C4  25000                                     RETURN 
 0C5                                            ;------------------------------------------------------------------------------------
 0C5                                            ; Procedure:  SPM_print_hex()
 0C5                                            ; Registers Used:
 0C5                                            ;        Bank0 : s9, s8, s7, s5,
 0C5                                            ;   Bank1 : None
 0C5                                            ;
 0C5                                            ; Arguments:
 0C5                                            ;    Bank0 : s6
 0C5                                            ;   Bank1 : None
 0C5                                            ;
 0C5                                            ; Calls:  UART_TX
 0C5                                            ;
 0C5                                            ; Returns:  None
 0C5                                            ;
 0C5                                            ; Return Flags:  None
 0C5                                            ;
 0C5                                            ; Description:  Prints a 64-bit double precision number starting from location
 0C5                                            ; index (s9) of SPM.
 0C5                                            ;------------------------------------------------------------------------------------
 0C5                             SPM_print_hex: 
 0C5  01808                                     LOAD s8, 08[8'd]                               ; Double precision has 8 bytes
 0C6                            print_hex_loop: 
 0C6  0A590                                     FETCH s5, (s9)
 0C7  00750                                     LOAD s7, s5                                    ; Copy s5
 0C8  1450E                                     SR0 s5                                         ; shift the 4 bit on the left to the right
 0C9  1450E                                     SR0 s5
 0CA  1450E                                     SR0 s5
 0CB  1450E                                     SR0 s5
 0CC  1D50A                                     COMPARE s5, 0A[10'd]
 0CD  3A0CF                                     JUMP C, 0CF[less_or_eq_to_nine]
 0CE  220D1                                     JUMP 0D1[greater_than_nine]
 0CF                        less_or_eq_to_nine: 
 0CF  11530                                     ADD s5, 30[48'd]
 0D0  220D2                                     JUMP 0D2[done_adding]
 0D1                         greater_than_nine: 
 0D1  11557                                     ADD s5, 57[87'd]
 0D2                               done_adding: 
 0D2  20078                                     CALL 078[UART_TX]                              ; send it to UART via s5
 0D3                                            ;--- Second nibble
 0D3  0370F                                     AND s7, 0F                                     ; select the 4 bit on the right
 0D4  1D70A                                     COMPARE s7, 0A[10'd]
 0D5  3A0D7                                     JUMP C, 0D7[less_or_eq_to_nine2]
 0D6  220D9                                     JUMP 0D9[greater_than_nine2]
 0D7                       less_or_eq_to_nine2: 
 0D7  11730                                     ADD s7, 30[48'd]
 0D8  220DA                                     JUMP 0DA[done_adding2]
 0D9                        greater_than_nine2: 
 0D9  11757                                     ADD s7, 57[87'd]
 0DA                              done_adding2: 
 0DA  00570                                     LOAD s5, s7
 0DB  20078                                     CALL 078[UART_TX]                              ; send it to UART via s5
 0DC                     done_printing_one_hex: 
 0DC  11901                                     ADD s9, 01                                     ; read the next byte
 0DD  19801                                     SUB s8, 01[1'd]                                ; decrement the counter
 0DE  0D8FF                                     TEST s8, FF                                    ; Is cunter zero?
 0DF  31000                                     RETURN Z
 0E0  220C6                                     JUMP 0C6[print_hex_loop]
 0E1  25000                                     RETURN 
 0E2                                            ;-----------------------------------------------------------------------------------
 0E2                                            ; Software Implementation of Floating-Point Arithmetic, Double-Precision (64 bit).
 0E2                                            ;
 0E2                                            ; beta(radix) = 2, k(width) = 64, p(precision) = 53, e_max = 1023
 0E2                                            ;
 0E2                                            ;------------------------------------------------------------------------------------
 0E2                                            ; Procedure:  add_dp()
 0E2                                            ; Registers Used:
 0E2                                            ;        Bank0 :
 0E2                                            ;   Bank1 : None
 0E2                                            ;
 0E2                                            ; Arguments:
 0E2                                            ;    Scratch Pad Memory (SPM-256): position 0 to 15.
 0E2                                            ;   x: SPM position 0 to 7.
 0E2                                            ;   y: SPM position 8 to 15.
 0E2                                            ;
 0E2                                            ;    Bank0 : None
 0E2                                            ;   Bank1 : None
 0E2                                            ;
 0E2                                            ; Calls:  None
 0E2                                            ;
 0E2                                            ; Returns:  Scratch Pad Memory (SPM-256): position 0 to 7.
 0E2                                            ;    r: SPM position 0 to 7.
 0E2                                            ;
 0E2                                            ; Return Flags:  None
 0E2                                            ;
 0E2                                            ; Description:  Adds two double-precisin IEEE-754 numbers.
 0E2                                            ;    Computes x + y and returns the result in r.
 0E2                                            ;    x + y = r.
 0E2                                            ;------------------------------------------------------------------------------------
 0E2                                    add_dp: 
 0E2  25000                                     RETURN 
 0E3                                            ;------------------------------------------------------------------------------------
 0E3                                            ; Procedure:  load_8Bytes_from_ext_BRAM()
 0E3                                            ; Registers Used:
 0E3                                            ;        Bank0 : s6, s5, s9
 0E3                                            ;   Bank1 : None
 0E3                                            ;
 0E3                                            ; Arguments:
 0E3                                            ;    Bank0 : [s6, s5] : The address of starting point of memory
 0E3                                            ;   Bank1 : None
 0E3                                            ;
 0E3                                            ; Calls:  Read_ext_mem()
 0E3                                            ;
 0E3                                            ; Returns:  8 bytes in SPM, starts  at s8.
 0E3                                            ;
 0E3                                            ; Return Flags:  None
 0E3                                            ;
 0E3                                            ; Description:  Load 8 sequential bytes into SPM starting at position set in s8.
 0E3                                            ;------------------------------------------------------------------------------------
 0E3                 load_8Bytes_from_ext_BRAM: 
 0E3  00980                                     LOAD s9, s8                                    ; Copy s8
 0E4  11908                                     ADD s9, 08[8'd]                                ; After 8 reads the the loop must stop
 0E5                 read_8bytes_ext_BRAM_loop: 
 0E5  200ED                                     CALL 0ED[Read_ext_mem]                         ; Read the first byte and save it in s7
 0E6  2E780                                     STORE s7, (s8)
 0E7  11501                                     ADD s5, 01                                     ; Point to the next byte
 0E8  13600                                     ADDCY s6, 00
 0E9  11801                                     ADD s8, 01[1'd]                                ; Increment SPM pointer by 1
 0EA  1C890                                     COMPARE s8, s9                                 ; 8 bytes reached ?
 0EB  3A0E5                                     JUMP C, 0E5[read_8bytes_ext_BRAM_loop]         ; Jump if s8 is less than s9
 0EC  25000                                     RETURN 
 0ED                                            ;------------------------------------------------------------------------------------
 0ED                                            ; Procedure:  Read_ext_mem()
 0ED                                            ; Registers Used:
 0ED                                            ;        Bank0 : s7, s6, s5
 0ED                                            ;   Bank1 : None
 0ED                                            ;
 0ED                                            ; Arguments:
 0ED                                            ;    Bank0 : None
 0ED                                            ;   Bank1 : None
 0ED                                            ;
 0ED                                            ; Calls:  None
 0ED                                            ;
 0ED                                            ; Returns:  s7: The read data
 0ED                                            ;
 0ED                                            ; Return Flags:  None
 0ED                                            ;
 0ED                                            ; Description:  Reads the external memory.
 0ED                                            ;
 0ED                                            ;   [s6, s5] must contains the read address (12 bits).
 0ED                                            ;   - Bit 7 of s6 is clock  enable.
 0ED                                            ;   Uppder nibble of s6 must contain 8, to enable the block RAM.
 0ED                                            ;------------------------------------------------------------------------------------
 0ED                              Read_ext_mem: 
 0ED  05680                                     OR s6, 80                                      ; Enable BRAM clock
 0EE  2D501                                     OUTPUT s5, 01[Extra_mem_lo_output_port]
 0EF  2D602                                     OUTPUT s6, 02[Extra_mem_hi_output_port]
 0F0  04550                                     OR s5, s5                                      ; Delay
 0F1  09702                                     INPUT s7, 02[Extra_mem_input_port]
 0F2  0367F                                     AND s6, 7F                                     ; Disable BRAM clock
 0F3  2D602                                     OUTPUT s6, 02[Extra_mem_hi_output_port]
 0F4  25000                                     RETURN 
 0F5                                            ;------------------------------------------------------------------------------------
 0F5                                            ; Procedure:  Write_ext_mem()
 0F5                                            ; Registers Used:
 0F5                                            ;        Bank0 : s7, s6, s5
 0F5                                            ;   Bank1 : None
 0F5                                            ;
 0F5                                            ; Arguments:
 0F5                                            ;    Bank0 : None
 0F5                                            ;   Bank1 : None
 0F5                                            ;
 0F5                                            ; Calls:  None
 0F5                                            ;
 0F5                                            ; Returns:  None
 0F5                                            ;
 0F5                                            ; Return Flags:  None
 0F5                                            ;
 0F5                                            ; Description:  Writes to external memory.
 0F5                                            ;
 0F5                                            ;   [s6, s5] must contains the write address.
 0F5                                            ;   - Bit 7 of s6 is Clock Enable
 0F5                                            ;   - Bit 6 of s6 is Write Enable
 0F5                                            ;   - Write at address:  EW00_AAAA_AAAA_AAAA
 0F5                                            ;   - Uppder nibble of s6 must contain C, to enable the block RAM
 0F5                                            ;          and write enable.
 0F5                                            ;   - s7 regiser has 8-bit data to be written at location [s6, s5].
 0F5                                            ;
 0F5                                            ;------------------------------------------------------------------------------------
 0F5                             Write_ext_mem: 
 0F5  056C0                                     OR s6, C0                                      ; Enable block RAM and write enable.
 0F6  2D703                                     OUTPUT s7, 03[Extra_mem_output_port]
 0F7  2D501                                     OUTPUT s5, 01[Extra_mem_lo_output_port]
 0F8  2D602                                     OUTPUT s6, 02[Extra_mem_hi_output_port]
 0F9  04550                                     OR s5, s5                                      ; Delay
 0FA  0363F                                     AND s6, 3F                                     ; disable block RAM and write enable.
 0FB  2D602                                     OUTPUT s6, 02[Extra_mem_hi_output_port]
 0FC  25000                                     RETURN 
 0FD                                            ;------------------------------------------------------------------------------------
 0FD                                            ; Procedure:  SPM_load_8Bytes()
 0FD                                            ; Registers Used:
 0FD                                            ;        Bank0 : sB, sA, s8, s6, s5
 0FD                                            ;   Bank1 : None
 0FD                                            ;
 0FD                                            ; Arguments:
 0FD                                            ;    Bank0 : s5
 0FD                                            ;   Bank1 : None
 0FD                                            ;
 0FD                                            ; Calls:  None
 0FD                                            ;
 0FD                                            ; Returns:  None
 0FD                                            ;
 0FD                                            ; Return Flags:  None
 0FD                                            ;
 0FD                                            ; Description:  Load 8 sequential bytes into SPM starting at position set in s5.
 0FD                                            ;------------------------------------------------------------------------------------
 0FD                                            ; SPM_load_8Bytes:
 0FD                                            ;  LOAD s8, s5  ; Set SPM starting position
 0FD                                            ;  LOAD s6, s5
 0FD                                            ;  ADD s6, 8'd
 0FD                                            ; SPM_load_loop:
 0FD                                            ;  CALL@ (sB, sA)  ; read the first byte in s5
 0FD                                            ;  STORE s5, (s8)
 0FD                                            ;  ADD sA, 1'd  ; read the next byte
 0FD                                            ;  ADDCY sB, 0'd
 0FD                                            ;  ADD s8, 1'd  ; Increment SPM pointer by 1
 0FD                                            ;  COMPAREARE s8, s6  ; 8 bytes reached ?
 0FD                                            ;  JUMP C,SPM_load_loop
 0FD                                            ;  RETURN
 0FD                                            ;------------------------------------------------------------------------------------
 0FD                                            ; Procedure:  invoke_done_interrupt()
 0FD                                            ;
 0FD                                            ; Registers Used: Bank0 : s5, s6
 0FD                                            ;   Bank1 : None
 0FD                                            ;
 0FD                                            ; Arguments:  Bank0 : [s1,s0]
 0FD                                            ;   Bank1 : None
 0FD                                            ;
 0FD                                            ; Calls:  None
 0FD                                            ;
 0FD                                            ; Returns:  s0
 0FD                                            ;
 0FD                                            ; Return Flags:  None
 0FD                                            ;
 0FD                                            ; Description: Invoke Done interrupt
 0FD                                            ;------------------------------------------------------------------------------------
 0FD                     invoke_done_interrupt: 
 0FD  01500                                     LOAD s5, 00
 0FE  2D504                                     OUTPUT s5, 04[irqs_output_port]
 0FF  04550                                     OR s5, s5                                      ; Delay
 100  01501                                     LOAD s5, 01
 101  2D504                                     OUTPUT s5, 04[irqs_output_port]
 102                                            ; delay after setting the line to high: 32 cycles
 102  01640                                     LOAD s6, 40
 103                            delay_int_loop: 
 103  19601                                     SUB s6, 01
 104  36103                                     JUMP NZ, 103[delay_int_loop]
 105  01500                                     LOAD s5, 00
 106  2D504                                     OUTPUT s5, 04[irqs_output_port]
 107  25000                                     RETURN 
 108                                            ;------------------------------------------------------------------------------------
 108                                            ; Procedure:  write_result_to_external_memory()
 108                                            ;
 108                                            ; Registers Used: Bank0 : s5, s6
 108                                            ;   Bank1 : None
 108                                            ;
 108                                            ; Arguments:  Bank0 : [s1,s0]
 108                                            ;   Bank1 : None
 108                                            ;
 108                                            ; Calls:  None
 108                                            ;
 108                                            ; Returns:  s0
 108                                            ;
 108                                            ; Return Flags:  None
 108                                            ;
 108                                            ; Description:  Write the arithmathic result to external memory.
 108                                            ;------------------------------------------------------------------------------------
 108           write_result_to_external_memory: 
 108  01600                                     LOAD s6, 00                                    ; Write result at address  010
 109  01510                                     LOAD s5, 10
 10A  0B717                                     FETCH s7, 17[r_0]
 10B                                            ;LOAD s7, 25
 10B  200F5                                     CALL 0F5[Write_ext_mem]
 10C  01600                                     LOAD s6, 00                                    ; Write result at address  011
 10D  01511                                     LOAD s5, 11
 10E  0B716                                     FETCH s7, 16[r_1]
 10F                                            ;LOAD s7, 26
 10F  200F5                                     CALL 0F5[Write_ext_mem]
 110  01600                                     LOAD s6, 00                                    ; Write result at address  012
 111  01512                                     LOAD s5, 12
 112  0B715                                     FETCH s7, 15[r_2]
 113                                            ;LOAD s7, 27
 113  200F5                                     CALL 0F5[Write_ext_mem]
 114  01600                                     LOAD s6, 00                                    ; Write result at address  013
 115  01513                                     LOAD s5, 13
 116  0B714                                     FETCH s7, 14[r_3]
 117                                            ;LOAD s7, 28
 117  200F5                                     CALL 0F5[Write_ext_mem]
 118  01600                                     LOAD s6, 00                                    ; Write result at address  014
 119  01514                                     LOAD s5, 14
 11A  0B713                                     FETCH s7, 13[r_4]
 11B                                            ;LOAD s7, 29
 11B  200F5                                     CALL 0F5[Write_ext_mem]
 11C  01600                                     LOAD s6, 00                                    ; Write result at address  015
 11D  01515                                     LOAD s5, 15
 11E  0B712                                     FETCH s7, 12[r_5]
 11F                                            ;LOAD s7, 30
 11F  200F5                                     CALL 0F5[Write_ext_mem]
 120  01600                                     LOAD s6, 00                                    ; Write result at address  016
 121  01516                                     LOAD s5, 16
 122  0B711                                     FETCH s7, 11[r_6]
 123                                            ;LOAD s7, 31
 123  200F5                                     CALL 0F5[Write_ext_mem]
 124  01600                                     LOAD s6, 00                                    ; Write result at address  017
 125  01517                                     LOAD s5, 17
 126  0B710                                     FETCH s7, 10[r_7]
 127                                            ;LOAD s7, 32
 127  200F5                                     CALL 0F5[Write_ext_mem]
 128  25000                                     RETURN 
 129                                            ;-----------------------------------------------------------------------------------
 129                                            ; Software Implementation of Floating-Point Arithmetic, Double-Precision (64 bit).
 129                                            ;
 129                                            ; beta(radix) = 2, k(width) = 64, p(precision) = 53, e_max = 1023
 129                                            ;
 129                                            ;------------------------------------------------------------------------------------
 129                                            ; Procedure:   arith_add_x_y()
 129                                            ;
 129                                            ; Registers Used: Bank0 : All
 129                                            ;     Bank1 : None
 129                                            ;
 129                                            ; Arguments:   Bank0 :
 129                                            ;     Bank1 : None
 129                                            ;     SPM   : x = [x_7, x_6, ..., x_0]
 129                                            ;            y = [y_7, y_6, ..., y_0]
 129                                            ;
 129                                            ; Calls:
 129                                            ;     load_mx
 129                                            ;     load_my
 129                                            ;     swap_operands
 129                                            ;     count_nlz
 129                                            ;     round
 129                                            ;
 129                                            ; RETs:    None
 129                                            ;
 129                                            ; RET Flags:   None
 129                                            ;
 129                                            ; Description:  Adds two 64-bit double-precision floating point numbers.
 129                                            ;   This procedure always add. For subtraction set the sign of second  operand
 129                                            ; to negative due to the fact that x + (-y) = x - y.
 129                                            ;------------------------------------------------------------------------------------
 129                             arith_add_x_y: 
 129  2034E                                     CALL 34E[set_ops_status]
 12A  202FA                                     CALL 2FA[decompose_x]
 12B  20324                                     CALL 324[decompose_y]
 12C  0B13A                                     FETCH s1, 3A[op1_status]                       ; read the ops status
 12D  0B23B                                     FETCH s2, 3B[op2_status]                       ; read the ops status
 12E                                            ; We check op1 for
 12E                                            ; 1) NaN
 12E                                            ;  Yes: Check op2, if NaN then return Y_NaN else return X_NaN
 12E                                            ;  No:  Go to step 2.
 12E                                            ; 2) Infinity
 12E                                            ;  Yes: Check op2, if Inf then return_NaN_Inf
 12E                                            ;  No:  Go to step 3.
 12E                                            ; 3) Zero
 12E                                            ;  Yes: check if op2 is NaN then return_NaN_Inf else return y
 12E                                            ;  No:  swap_step
 12E                                            ; Check if op1 is NaN
 12E  0D110                                     TEST s1, 10
 12F  3213A                                     JUMP Z, 13A[final_op1_not_NaN]                 ; No
 130                             final_op1_NaN: ; Yes
 130                                            ; Check if op2 is NaN
 130  0D210                                     TEST s2, 10
 131  36133                                     JUMP NZ, 133[return_NAN]                       ; Yes
 132  22177                                     JUMP 177[return_x_NAN]
 133                                return_NAN: 
 133                                            ; check op1 NaN bit
 133  0B31B                                     FETCH s3, 1B[x_m6]
 134  0D308                                     TEST s3, 08
 135  32177                                     JUMP Z, 177[return_x_NAN]
 136                                            ; op1 NaN bit is 1, so check op2 NaN bit
 136  0B326                                     FETCH s3, 26[y_m6]
 137  0D308                                     TEST s3, 08
 138  321BC                                     JUMP Z, 1BC[return_y_NAN]
 139  22177                                     JUMP 177[return_x_NAN]
 13A                         final_op1_not_NaN: 
 13A                                            ; +inf + + inf = +inf
 13A                                            ; +inf + - inf = +NaN
 13A                                            ; -inf + + inf = +NaN
 13A                                            ; -inf + - inf = -inf
 13A                                            ; infinity sign is the AND of both operands' sign bits.
 13A                                            ; Result NaN bit is XOR of both operands' sign bits.
 13A                                            ; Check if op1 is Inf
 13A  0D120                                     TEST s1, 20
 13B  32141                                     JUMP Z, 141[final_op1_not_Inf]                 ; No
 13C                             final_op1_Inf: ; Yes
 13C                                            ; Check if op2 is Inf
 13C  0D220                                     TEST s2, 20
 13D  361CF                                     JUMP NZ, 1CF[return_y_NAN_Inf]                 ; Yes
 13E                                            ; Check if op2 is NaN
 13E  0D210                                     TEST s2, 10
 13F  361BC                                     JUMP NZ, 1BC[return_y_NAN]                     ; Yes
 140  22165                                     JUMP 165[return_x]
 141                         final_op1_not_Inf: 
 141                                            ; Check if op1 is zero
 141  0D140                                     TEST s1, 40
 142  32148                                     JUMP Z, 148[check_final_op2]                   ; No
 143                         final_op1_is_zero: 
 143                                            ; Check if op2 is zero
 143  0D240                                     TEST s2, 40
 144  36156                                     JUMP NZ, 156[return_zero]                      ; Yes
 145                                            ; Check if op2 is NaN
 145  0D210                                     TEST s2, 10
 146  361BC                                     JUMP NZ, 1BC[return_y_NAN]                     ;Yes
 147  221AA                                     JUMP 1AA[return_y]
 148                                            ; Op1 is not NaN, Inf, and zero, so we conclude op1 is (sub)normal.
 148                                            ; We check op2 for
 148                                            ; 1) NaN
 148                                            ;  Yes: return_NaN_Inf
 148                                            ;  No:  Go to step 2.
 148                                            ; 2) Infinity
 148                                            ;  Yes: return_NaN_Inf
 148                                            ;  No:  return x
 148                                            ; 3) Zero
 148                                            ;  Yes: return zero
 148                                            ;  No:  swap_step
 148                           check_final_op2: 
 148                                            ; Check if op2 is NaN
 148  0D210                                     TEST s2, 10
 149  361BC                                     JUMP NZ, 1BC[return_y_NAN]                     ;Yes
 14A                         final_op2_not_NaN: ; NoSL0  s8
 14A  14900                                     SLA s9
 14B  14800                                     SLA s8
 14C  14900                                     SLA s9
 14D  14800                                     SLA s8
 14E  14900                                     SLA s9
 14F  14800                                     SLA s8
 150  14900                                     SLA s9
 151                                            ; +inf + + inf = +inf
 151                                            ; +inf + - inf = +NaN
 151                                            ; -inf + + inf = +NaN
 151                                            ; -inf + - inf = -inf
 151                                            ; infinity sign is the AND of both operands' sign bits.
 151                                            ; Result NaN bit is XOR of both operands' sign bits.
 151                                            ; Check if op2 is Inf
 151  0D220                                     TEST s2, 20
 152  361AA                                     JUMP NZ, 1AA[return_y]                         ; Yes
 153                         final_op2_not_Inf: ; No
 153                                            ; Check if op2 is zero
 153  0D240                                     TEST s2, 40
 154  36165                                     JUMP NZ, 165[return_x]                         ; Yes
 155                                            ; Both operators are (sub)normal. Perform the addition.
 155                                            ; op1 = subnormal op2 = subnormal  - Normal procedure works
 155                                            ; ex = 0    ey = 0
 155                                            ; op1 = subnormal op2 = normal   - hidden 0 must be injected.
 155                                            ; ex = 0    ey != 0   subnormal
 155                                            ; op1 = normal  op2 = subnormal  - hidden 0 must be injected.
 155                                            ; ex != 0    ey = 0
 155                                            ; op1 = normal  op2 = normal     - Normal procedure works
 155  221F2                                     JUMP 1F2[COMP_swap_ex]
 156                               return_zero: 
 156  01FFF                                     LOAD sF, FF
 157                                            ; +0 +0 => +0
 157                                            ; -0 +0 => +0
 157                                            ; +0 -0 => +0
 157                                            ; -0 -0 => -0
 157  0B118                                     FETCH s1, 18[x_sign]
 158  0B223                                     FETCH s2, 23[y_sign]
 159  02120                                     AND s1, s2                                     ; Calculate the sign of zero
 15A  03180                                     AND s1, 80                                     ; zero all other bits except sign
 15B  01000                                     LOAD s0, 00
 15C  2F011                                     STORE s0, 11[r_6]
 15D  2F012                                     STORE s0, 12[r_5]
 15E  2F013                                     STORE s0, 13[r_4]
 15F  2F014                                     STORE s0, 14[r_3]
 160  2F015                                     STORE s0, 15[r_2]
 161  2F016                                     STORE s0, 16[r_1]
 162  2F017                                     STORE s0, 17[r_0]
 163  2F110                                     STORE s1, 10[r_7]
 164  25000                                     RETURN 
 165                                  return_x: 
 165  01FFF                                     LOAD sF, FF
 166  0B700                                     FETCH s7, 00[x_7]
 167  0B601                                     FETCH s6, 01[x_6]
 168  0B502                                     FETCH s5, 02[x_5]
 169  0B403                                     FETCH s4, 03[x_4]
 16A  0B304                                     FETCH s3, 04[x_3]
 16B  0B205                                     FETCH s2, 05[x_2]
 16C  0B106                                     FETCH s1, 06[x_1]
 16D  0B007                                     FETCH s0, 07[x_0]
 16E  2F710                                     STORE s7, 10[r_7]
 16F  2F611                                     STORE s6, 11[r_6]
 170  2F512                                     STORE s5, 12[r_5]
 171  2F413                                     STORE s4, 13[r_4]
 172  2F314                                     STORE s3, 14[r_3]
 173  2F215                                     STORE s2, 15[r_2]
 174  2F116                                     STORE s1, 16[r_1]
 175  2F017                                     STORE s0, 17[r_0]
 176  25000                                     RETURN 
 177                              return_x_NAN: 
 177  01FFF                                     LOAD sF, FF
 178  0B700                                     FETCH s7, 00[x_7]
 179  0B601                                     FETCH s6, 01[x_6]
 17A  05608                                     OR s6, 08                                      ; ensure the result is NaN
 17B  0B502                                     FETCH s5, 02[x_5]
 17C  0B403                                     FETCH s4, 03[x_4]
 17D  0B304                                     FETCH s3, 04[x_3]
 17E  0B205                                     FETCH s2, 05[x_2]
 17F  0B106                                     FETCH s1, 06[x_1]
 180  0B007                                     FETCH s0, 07[x_0]
 181  2F710                                     STORE s7, 10[r_7]
 182  2F611                                     STORE s6, 11[r_6]
 183  2F512                                     STORE s5, 12[r_5]
 184  2F413                                     STORE s4, 13[r_4]
 185  2F314                                     STORE s3, 14[r_3]
 186  2F215                                     STORE s2, 15[r_2]
 187  2F116                                     STORE s1, 16[r_1]
 188  2F017                                     STORE s0, 17[r_0]
 189  25000                                     RETURN 
 18A                          return_x_NAN_Inf: 
 18A  01FFF                                     LOAD sF, FF
 18B                                            ; Read operand signs
 18B  0B900                                     FETCH s9, 00[x_7]
 18C  0B808                                     FETCH s8, 08[y_7]
 18D  03980                                     AND s9, 80                                     ; op1 sign bit
 18E  03880                                     AND s8, 80                                     ; op2 sign bit
 18F                                            ; +inf + + inf = +inf
 18F                                            ; +inf + - inf = +NaN
 18F                                            ; -inf + + inf = +NaN
 18F                                            ; -inf + - inf = -inf
 18F                                            ; infinity sign is the AND of both operands' sign bits.
 18F                                            ; Result NaN bit is XOR of both operands' sign bits.
 18F  00A90                                     LOAD sA, s9                                    ; copy s9 into sA
 190  02A80                                     AND sA, s8
 191  06980                                     XOR s9, s8
 192  0D980                                     TEST s9, 80
 193  32196                                     JUMP Z, 196[NaN_bit_off]
 194  01808                                     LOAD s8, 08
 195  22197                                     JUMP 197[done_applying_NaN_bit]
 196                               NaN_bit_off: 
 196  01800                                     LOAD s8, 00
 197                     done_applying_NaN_bit: 
 197  0B700                                     FETCH s7, 00[x_7]
 198  047A0                                     OR s7, sA                                      ; Apply infinity sign
 199  0B601                                     FETCH s6, 01[x_6]
 19A  04680                                     OR s6, s8                                      ; Apply Result NaN bit
 19B  0B502                                     FETCH s5, 02[x_5]
 19C  0B403                                     FETCH s4, 03[x_4]
 19D  0B304                                     FETCH s3, 04[x_3]
 19E  0B205                                     FETCH s2, 05[x_2]
 19F  0B106                                     FETCH s1, 06[x_1]
 1A0  0B007                                     FETCH s0, 07[x_0]
 1A1  2F710                                     STORE s7, 10[r_7]
 1A2  2F611                                     STORE s6, 11[r_6]
 1A3  2F512                                     STORE s5, 12[r_5]
 1A4  2F413                                     STORE s4, 13[r_4]
 1A5  2F314                                     STORE s3, 14[r_3]
 1A6  2F215                                     STORE s2, 15[r_2]
 1A7  2F116                                     STORE s1, 16[r_1]
 1A8  2F017                                     STORE s0, 17[r_0]
 1A9  25000                                     RETURN 
 1AA                                  return_y: 
 1AA  01FFF                                     LOAD sF, FF
 1AB  0B708                                     FETCH s7, 08[y_7]
 1AC  0B609                                     FETCH s6, 09[y_6]
 1AD  0B50A                                     FETCH s5, 0A[y_5]
 1AE  0B40B                                     FETCH s4, 0B[y_4]
 1AF  0B30C                                     FETCH s3, 0C[y_3]
 1B0  0B20D                                     FETCH s2, 0D[y_2]
 1B1  0B10E                                     FETCH s1, 0E[y_1]
 1B2  0B00F                                     FETCH s0, 0F[y_0]
 1B3  2F710                                     STORE s7, 10[r_7]
 1B4  2F611                                     STORE s6, 11[r_6]
 1B5  2F512                                     STORE s5, 12[r_5]
 1B6  2F413                                     STORE s4, 13[r_4]
 1B7  2F314                                     STORE s3, 14[r_3]
 1B8  2F215                                     STORE s2, 15[r_2]
 1B9  2F116                                     STORE s1, 16[r_1]
 1BA  2F017                                     STORE s0, 17[r_0]
 1BB  25000                                     RETURN 
 1BC                              return_y_NAN: 
 1BC  01FFF                                     LOAD sF, FF
 1BD  0B708                                     FETCH s7, 08[y_7]
 1BE  0B609                                     FETCH s6, 09[y_6]
 1BF  05608                                     OR s6, 08                                      ; ensure the result is NaN
 1C0  0B50A                                     FETCH s5, 0A[y_5]
 1C1  0B40B                                     FETCH s4, 0B[y_4]
 1C2  0B30C                                     FETCH s3, 0C[y_3]
 1C3  0B20D                                     FETCH s2, 0D[y_2]
 1C4  0B10E                                     FETCH s1, 0E[y_1]
 1C5  0B00F                                     FETCH s0, 0F[y_0]
 1C6  2F710                                     STORE s7, 10[r_7]
 1C7  2F611                                     STORE s6, 11[r_6]
 1C8  2F512                                     STORE s5, 12[r_5]
 1C9  2F413                                     STORE s4, 13[r_4]
 1CA  2F314                                     STORE s3, 14[r_3]
 1CB  2F215                                     STORE s2, 15[r_2]
 1CC  2F116                                     STORE s1, 16[r_1]
 1CD  2F017                                     STORE s0, 17[r_0]
 1CE  25000                                     RETURN 
 1CF                          return_y_NAN_Inf: 
 1CF  01FFF                                     LOAD sF, FF
 1D0                                            ; Read operand signs
 1D0  0B900                                     FETCH s9, 00[x_7]
 1D1  0B808                                     FETCH s8, 08[y_7]
 1D2  03980                                     AND s9, 80                                     ; op1 sign bit
 1D3  03880                                     AND s8, 80                                     ; op2 sign bit
 1D4                                            ; +inf + + inf = +inf
 1D4                                            ; +inf + - inf = +NaN
 1D4                                            ; -inf + + inf = +NaN
 1D4                                            ; -inf + - inf = -inf
 1D4                                            ; infinity sign is the AND of both operands' sign bits.
 1D4                                            ; Result NaN bit is XOR of both operands' sign bits.
 1D4  00A90                                     LOAD sA, s9                                    ; copy s9 into sA
 1D5  02A80                                     AND sA, s8
 1D6  06980                                     XOR s9, s8
 1D7  0B708                                     FETCH s7, 08[y_7]
 1D8                                            ; Apply the sign
 1D8  0DA80                                     TEST sA, 80
 1D9  361DC                                     JUMP NZ, 1DC[set_sign_bit_to_1]
 1DA                         set_sign_bit_to_0: 
 1DA  0377F                                     AND s7, 7F
 1DB  221DD                                     JUMP 1DD[set_sign_bit_done]
 1DC                         set_sign_bit_to_1: 
 1DC  05780                                     OR s7, 80
 1DD                         set_sign_bit_done: 
 1DD  0B609                                     FETCH s6, 09[y_6]
 1DE                                            ; Apply the sign
 1DE  0D980                                     TEST s9, 80
 1DF  361E2                                     JUMP NZ, 1E2[set_NaN_bit_to_1]
 1E0                          set_NaN_bit_to_0: 
 1E0  036F7                                     AND s6, F7
 1E1  221E3                                     JUMP 1E3[set_NaN_bit_done]
 1E2                          set_NaN_bit_to_1: 
 1E2  05608                                     OR s6, 08
 1E3                          set_NaN_bit_done: 
 1E3  0B50A                                     FETCH s5, 0A[y_5]
 1E4  0B40B                                     FETCH s4, 0B[y_4]
 1E5  0B30C                                     FETCH s3, 0C[y_3]
 1E6  0B20D                                     FETCH s2, 0D[y_2]
 1E7  0B10E                                     FETCH s1, 0E[y_1]
 1E8  0B00F                                     FETCH s0, 0F[y_0]
 1E9  2F710                                     STORE s7, 10[r_7]
 1EA  2F611                                     STORE s6, 11[r_6]
 1EB  2F512                                     STORE s5, 12[r_5]
 1EC  2F413                                     STORE s4, 13[r_4]
 1ED  2F314                                     STORE s3, 14[r_3]
 1EE  2F215                                     STORE s2, 15[r_2]
 1EF  2F116                                     STORE s1, 16[r_1]
 1F0  2F017                                     STORE s0, 17[r_0]
 1F1  25000                                     RETURN 
 1F2                                            ;--------------------------------------------------------------------------
 1F2                              COMP_swap_ex: 
 1F2                                            ; Read ex : [s1, s0]
 1F2  0B119                                     FETCH s1, 19[x_ex7]
 1F3  0B01A                                     FETCH s0, 1A[x_ex6]
 1F4                                            ; Read ey: [s3, s2]
 1F4  0B324                                     FETCH s3, 24[y_ex7]
 1F5  0B225                                     FETCH s2, 25[y_ex6]
 1F6                                            ; COMPARE ex [s1, s0] VS ey [s3, s2]
 1F6  1C020                                     COMPARE s0, s2
 1F7  1E130                                     COMPARECY s1, s3
 1F8  3A206                                     JUMP C, 206[ex_less_than_ey]
 1F9                  ex_greater_equal_than_ey: 
 1F9  36207                                     JUMP NZ, 207[swap_done]
 1FA                               ex_equal_ey: 
 1FA                                            ;when both exponents are equal then we compare the significand
 1FA  37001                                     REGBANK B
 1FB  2029E                                     CALL 29E[load_mx]
 1FC  202A7                                     CALL 2A7[load_my]
 1FD  1C190                                     COMPARE s1, s9
 1FE  1E2A0                                     COMPARECY s2, sA
 1FF  1E3B0                                     COMPARECY s3, sB
 200  1E4C0                                     COMPARECY s4, sC
 201  1E5D0                                     COMPARECY s5, sD
 202  1E6E0                                     COMPARECY s6, sE
 203  1E7F0                                     COMPARECY s7, sF
 204  37000                                     REGBANK A
 205  3E207                                     JUMP NC, 207[swap_done]
 206                           ex_less_than_ey: 
 206  202B0                                     CALL 2B0[swap_operands]
 207                                 swap_done: 
 207                                            ; Reread ex : [s1, s0]
 207  0B119                                     FETCH s1, 19[x_ex7]
 208  0B01A                                     FETCH s0, 1A[x_ex6]
 209                                            ; Reread ey: [s3, s2]
 209  0B324                                     FETCH s3, 24[y_ex7]
 20A  0B225                                     FETCH s2, 25[y_ex6]
 20B                                            ; Save the sign of the bigger number into result.
 20B  0BF18                                     FETCH sF, 18[x_sign]
 20C  2FF2E                                     STORE sF, 2E[r_sign]
 20D                                            ;-------------------------------------------- --------------------------
 20D                                            ;     Exponent Alignment
 20D                                            ;-----------------------------------------------------------------------
 20D                                            ; We set "er" as "ex"
 20D  2F12F                                     STORE s1, 2F[r_ex7]                            ; Write the exponent of result in SPM
 20E  2F030                                     STORE s0, 30[r_ex6]
 20F                                            ; ex = Ex - bias + 1 - nx
 20F                                            ; ey = Ey - bias + 1 - ny
 20F                                            ; ex - nx - ey + ny
 20F                                            ;  where nx and ny are normal bits. means if op is normal nx = 1
 20F                                            ;  otheriwse nx = 0.
 20F                                            ; Is op1 normal?
 20F  0B43A                                     FETCH s4, 3A[op1_status]
 210  0D401                                     TEST s4, 01
 211  36214                                     JUMP NZ, 214[op1_is_normal_nx_is_1]
 212  11001                                     ADD s0, 01                                     ; nx = 0
 213  13100                                     ADDCY s1, 00
 214                     op1_is_normal_nx_is_1: 
 214                                            ; Is op2 normal?
 214  0B43B                                     FETCH s4, 3B[op2_status]
 215  0D401                                     TEST s4, 01
 216  36219                                     JUMP NZ, 219[op2_is_normal_ny_is_1]
 217  11201                                     ADD s2, 01                                     ; ny = 0
 218  13300                                     ADDCY s3, 00
 219                     op2_is_normal_ny_is_1: 
 219  18020                                     SUB s0, s2                                     ;ex - ey
 21A  1A130                                     SUBCY s1, s3
 21B                                            ; ex = ey so (ex - ey) will set zero flag
 21B                                            ;  thus we don't need to shift mantisa right
 21B  32247                                     JUMP Z, 247[my_mantisa_shift_right_done]
 21C                                            ; Check if [s1, s0] is more than 56, if yes then reduce it to 56 as
 21C                                            ; shofting to right more than 56 times sets the whole mantisa
 21C                                            ; to zero completely
 21C  1D038                                     COMPARE s0, 38
 21D  1F100                                     COMPARECY s1, 00
 21E  3A221                                     JUMP C, 221[not_a_big_shift]                   ; s0 is less than 56
 21F  01038                                     LOAD s0, 38
 220  01100                                     LOAD s1, 00
 221                           not_a_big_shift: 
 221                                            ; Shift "my" to right by (ex - ey) in [s1, s0]:
 221  202A7                                     CALL 2A7[load_my]
 222  14F0E                                     SR0 sF
 223  14E08                                     SRA sE
 224  14D08                                     SRA sD
 225  14C08                                     SRA sC
 226  14B08                                     SRA sB
 227  14A08                                     SRA sA
 228  14908                                     SRA s9
 229  14808                                     SRA s8                                         ; extra bits: gaurd-round-sticky-xxxxx
 22A  19001                                     SUB s0, 01                                     ; subtract by 1 to take into account the manual
 22B  1B100                                     SUBCY s1, 00                                   ; first round shift:  ex - ey - 1
 22C  3223C                                     JUMP Z, 23C[my_mantisa_shift_right_loop_done]
 22D               my_mantisa_shift_right_loop: 
 22D  14F0E                                     SR0 sF                                         ; 52 bit "my" mantisa right shift by 1-bit
 22E  14E08                                     SRA sE                                         ;  loop for (ex - ey - 1) times
 22F  14D08                                     SRA sD
 230  14C08                                     SRA sC
 231  14B08                                     SRA sB
 232  14A08                                     SRA sA
 233  14908                                     SRA s9
 234  14808                                     SRA s8                                         ; extra bits: gaurd-round-sticky-xxxxx
 235                                            ; if sticky bit of s8 ever becomes 1 set sticky bit of op2 to 1
 235  0D820                                     TEST s8, 20
 236  32239                                     JUMP Z, 239[dont_set_sticky_bit_y]
 237  01220                                     LOAD s2, 20
 238  2F22D                                     STORE s2, 2D[y_grs]
 239                     dont_set_sticky_bit_y: 
 239  19001                                     SUB s0, 01
 23A  1B100                                     SUBCY s1, 00
 23B  3622D                                     JUMP NZ, 22D[my_mantisa_shift_right_loop]
 23C          my_mantisa_shift_right_loop_done: 
 23C                                            ; Save "my" back to SMP
 23C  2FF26                                     STORE sF, 26[y_m6]
 23D  2FE27                                     STORE sE, 27[y_m5]
 23E  2FD28                                     STORE sD, 28[y_m4]
 23F  2FC29                                     STORE sC, 29[y_m3]
 240  2FB2A                                     STORE sB, 2A[y_m2]
 241  2FA2B                                     STORE sA, 2B[y_m1]
 242  2F92C                                     STORE s9, 2C[y_m0]
 243  0B22D                                     FETCH s2, 2D[y_grs]                            ; Update the gr bits for y
 244  04820                                     OR s8, s2                                      ; Apply sticky bit
 245  038E0                                     AND s8, E0                                     ; Zero all bits except grs
 246  2F82D                                     STORE s8, 2D[y_grs]
 247               my_mantisa_shift_right_done: 
 247                                            ;---------------------------------------------------------------------------
 247                                            ; Convert to two's complement
 247                                            ;---------------------------------------------------------------------------
 247  0B018                                     FETCH s0, 18[x_sign]                           ; Read sign bit of x
 248  0D080                                     TEST s0, 80                                    ; Test the x sign bit
 249  32257                                     JUMP Z, 257[sx_is_positive]
 24A                                            ; x is negative
 24A  0B023                                     FETCH s0, 23[y_sign]                           ; Read sign bit of y
 24B  0D080                                     TEST s0, 80
 24C  32252                                     JUMP Z, 252[sx_is_neg_sy_is_pos]
 24D                                            ; x is negative , y is negative
 24D                                            ; Set the result sign as negative
 24D  01080                                     LOAD s0, 80
 24E  2F02E                                     STORE s0, 2E[r_sign]
 24F  203D3                                     CALL 3D3[twos_mx]
 250  203ED                                     CALL 3ED[twos_my]
 251  22263                                     JUMP 263[perform_addition]
 252                       sx_is_neg_sy_is_pos: 
 252                                            ; Set the result sign as negative
 252  01080                                     LOAD s0, 80
 253  2F02E                                     STORE s0, 2E[r_sign]
 254  203D3                                     CALL 3D3[twos_mx]
 255  202A7                                     CALL 2A7[load_my]
 256  22263                                     JUMP 263[perform_addition]
 257                            sx_is_positive: 
 257  0B008                                     FETCH s0, 08[y_7]                              ; Read sign bit of y
 258  0D080                                     TEST s0, 80
 259  3225F                                     JUMP Z, 25F[sx_sy_is_positive]
 25A                                            ; x is positive but y is negative
 25A                                            ; Set the result sign as positive
 25A  01000                                     LOAD s0, 00
 25B  2F02E                                     STORE s0, 2E[r_sign]
 25C  2029E                                     CALL 29E[load_mx]
 25D  203ED                                     CALL 3ED[twos_my]
 25E  22263                                     JUMP 263[perform_addition]
 25F                         sx_sy_is_positive: 
 25F                                            ; Set the result sign as positive
 25F  01000                                     LOAD s0, 00
 260  2F02E                                     STORE s0, 2E[r_sign]
 261  2029E                                     CALL 29E[load_mx]
 262  202A7                                     CALL 2A7[load_my]
 263                          perform_addition: 
 263                                            ; Add mx and my
 263  10080                                     ADD s0, s8
 264  12190                                     ADDCY s1, s9
 265  122A0                                     ADDCY s2, sA
 266  123B0                                     ADDCY s3, sB
 267  124C0                                     ADDCY s4, sC
 268  125D0                                     ADDCY s5, sD
 269  126E0                                     ADDCY s6, sE
 26A  127F0                                     ADDCY s7, sF
 26B                                            ; Is negative ?
 26B  0D740                                     TEST s7, 40
 26C  32280                                     JUMP Z, 280[dont_apply_twos]
 26D  070E0                                     XOR s0, E0                                     ; toggle all bits and then add 1
 26E  071FF                                     XOR s1, FF
 26F  072FF                                     XOR s2, FF
 270  073FF                                     XOR s3, FF
 271  074FF                                     XOR s4, FF
 272  075FF                                     XOR s5, FF
 273  076FF                                     XOR s6, FF
 274  0777F                                     XOR s7, 7F
 275  11020                                     ADD s0, 20                                     ; Add 1 to the sticky bit
 276  13100                                     ADDCY s1, 00
 277  13200                                     ADDCY s2, 00
 278  13300                                     ADDCY s3, 00
 279  13400                                     ADDCY s4, 00
 27A  13500                                     ADDCY s5, 00
 27B  13600                                     ADDCY s6, 00
 27C  13700                                     ADDCY s7, 00
 27D  01880                                     LOAD s8, 80
 27E  2F82E                                     STORE s8, 2E[r_sign]
 27F  22282                                     JUMP 282[sign_calc_done]
 280                           dont_apply_twos: 
 280  01800                                     LOAD s8, 00
 281  2F82E                                     STORE s8, 2E[r_sign]
 282                            sign_calc_done: 
 282                                            ; TEST s7, 10
 282                                            ; JUMP Z, carry_not_found_dont_shift_right_by_one
 282                                            ; carry found
 282                                            ; SR0  s7    ; shift left by 1
 282                                            ; SRA s6
 282                                            ; SRA s5
 282                                            ; SRA s4
 282                                            ; SRA s3
 282                                            ; SRA s2
 282                                            ; SRA s1
 282                                            ; SRA s0
 282                                            ; FETCH s8, r_ex6    ; Yes: Increment exponent by 1
 282                                            ; FETCH s9, r_ex7
 282                                            ; ADD  s8, 01
 282                                            ; ADDCY s9, 00
 282                                            ; STORE s8, r_ex6
 282                                            ; STORE s9, r_ex7
 282                                            ; JUMP no_carry
 282                                            ;carry_not_found_dont_shift_right_by_one:
 282                                            ; There is carry so apply 2'scomplement
 282                                            ; Check both operands are normal
 282                                            ;FETCH  sF, op1_status
 282                                            ;FETCH  sE, op2_status
 282                                            ;AND  sF, sE
 282                                            ;TEST sF, 01
 282                                            ;JUMP NZ, both_ops_normals
 282                                            ;JUMP no_carry
 282                                            ;both_ops_normals:  ; here 20 in s7 means overflow
 282                                            ; SR0  s7    ; shift left by 1
 282                                            ; SRA s6
 282                                            ; SRA s5
 282                                            ; SRA s4
 282                                            ; SRA s3
 282                                            ; SRA s2
 282                                            ; SRA s1
 282                                            ; SRA s0
 282                                            ; FETCH s8, r_ex6    ; Yes: Increment exponent by 1
 282                                            ; FETCH s9, r_ex7
 282                                            ; ADD  s8, 01
 282                                            ; ADDCY s9, 00
 282                                            ; STORE s8, r_ex6
 282                                            ; STORE s9, r_ex7
 282                                            ;no_carry:
 282                                            ;TEST s7, 40
 282                                            ;JUMP Z, overflow_not_found
 282                                            ; overflow found
 282                                            ;overflow_not_found:
 282                                            ; Check both operands are subnormals
 282                                            ; FETCH  sF, op1_status
 282                                            ; FETCH  sE, op2_status
 282                                            ; AND  sF, sE
 282                                            ; TEST sF, 80
 282                                            ; JUMP NZ, both_ops_subnormals
 282                                            ; Both ops not subnormal therefore normalize
 282  20407                                     CALL 407[normalize]                            ; normalize
 283  202E3                                     CALL 2E3[round]
 284  20407                                     CALL 407[normalize]                            ; normalize
 285  202E3                                     CALL 2E3[round]
 286  20407                                     CALL 407[normalize]                            ; normalize
 287                                            ;both_ops_subnormals:
 287                                            ; CALL  round
 287                                            ; Compose the result:
 287                                            ;  r exponent  = [s9, s8],
 287                                            ; r mantisa  = [s7, s6, ..., s1]
 287                                            ; r sign     = r_sign
 287                                            ; JUMP  normalizaion_done
 287                                            ;dont_normalize_as_both_are_subnormals:
 287                                            ; TEST s7, 10 ; Subnormals addition produced carry?
 287                                            ; JUMP Z, normalizaion_done  ; No
 287                                            ;normalizaion_done:
 287                                            ; Compose
 287  0B830                                     FETCH s8, 30[r_ex6]
 288  0B92F                                     FETCH s9, 2F[r_ex7]
 289  14806                                     SL0 s8
 28A  14900                                     SLA s9
 28B  14800                                     SLA s8
 28C  14900                                     SLA s9
 28D  14800                                     SLA s8
 28E  14900                                     SLA s9
 28F  14800                                     SLA s8
 290  14900                                     SLA s9
 291  0370F                                     AND s7, 0F
 292  04780                                     OR s7, s8
 293                                            ; Apply the result sign
 293  0BA2E                                     FETCH sA, 2E[r_sign]
 294  049A0                                     OR s9, sA
 295                                            ; Save the result in SMP
 295  2F117                                     STORE s1, 17[r_0]
 296  2F216                                     STORE s2, 16[r_1]
 297  2F315                                     STORE s3, 15[r_2]
 298  2F414                                     STORE s4, 14[r_3]
 299  2F513                                     STORE s5, 13[r_4]
 29A  2F612                                     STORE s6, 12[r_5]
 29B  2F711                                     STORE s7, 11[r_6]
 29C  2F910                                     STORE s9, 10[r_7]
 29D  25000                                     RETURN 
 29E                                            ;------------------------------------------------------------------------------------
 29E                                            ; Procedure:  load_mx()
 29E                                            ; Registers Used:
 29E                                            ;        Bank0 : s7, s6, ... , s0
 29E                                            ;    Bank1 : None
 29E                                            ;    SPM   : op1_status
 29E                                            ;
 29E                                            ; Arguments:
 29E                                            ;     Bank0 : None
 29E                                            ;    Bank1 : None
 29E                                            ;
 29E                                            ; Calls:   None
 29E                                            ;
 29E                                            ; RETs:   None
 29E                                            ;
 29E                                            ; RETURN Flags:  None
 29E                                            ;
 29E                                            ; Description: Load x oeprand mantisa to register s7 down to s0.
 29E                                            ;    - Hidden bit aleardy has been set in x_m6.
 29E                                            ;    - gsr bits apears in s0.
 29E                                            ;------------------------------------------------------------------------------------
 29E                                   load_mx: 
 29E                                            ; Load mx into registers
 29E  0B71B                                     FETCH s7, 1B[x_m6]
 29F  0B61C                                     FETCH s6, 1C[x_m5]
 2A0  0B51D                                     FETCH s5, 1D[x_m4]
 2A1  0B41E                                     FETCH s4, 1E[x_m3]
 2A2  0B31F                                     FETCH s3, 1F[x_m2]
 2A3  0B220                                     FETCH s2, 20[x_m1]
 2A4  0B121                                     FETCH s1, 21[x_m0]
 2A5  0B022                                     FETCH s0, 22[x_grs]
 2A6  25000                                     RETURN 
 2A7                                            ;------------------------------------------------------------------------------------
 2A7                                            ; Procedure:  load_my()
 2A7                                            ; Registers Used:
 2A7                                            ;        Bank0 : sF, sE, ... , s8
 2A7                                            ;    Bank1 : None
 2A7                                            ;    SPM   : op1_status
 2A7                                            ;
 2A7                                            ; Arguments:
 2A7                                            ;     Bank0 : None
 2A7                                            ;    Bank1 : None
 2A7                                            ;result_is_positive
 2A7                                            ; Calls:   None
 2A7                                            ;
 2A7                                            ; RETs:   None
 2A7                                            ;
 2A7                                            ; RETURN Flags:  None
 2A7                                            ;
 2A7                                            ; Description: Load y oeprand mantisa to register sF down to s8.
 2A7                                            ;    - Hidden bit aleardy has been set in x_m6.
 2A7                                            ;    - gsr bits apears in s0.
 2A7                                            ;------------------------------------------------------------------------------------
 2A7                                   load_my: 
 2A7                                            ; Load mx into registers
 2A7  0BF26                                     FETCH sF, 26[y_m6]
 2A8  0BE27                                     FETCH sE, 27[y_m5]
 2A9  0BD28                                     FETCH sD, 28[y_m4]
 2AA  0BC29                                     FETCH sC, 29[y_m3]
 2AB  0BB2A                                     FETCH sB, 2A[y_m2]
 2AC  0BA2B                                     FETCH sA, 2B[y_m1]
 2AD  0B92C                                     FETCH s9, 2C[y_m0]
 2AE  0B82D                                     FETCH s8, 2D[y_grs]
 2AF  25000                                     RETURN 
 2B0                                            ;------------------------------------------------------------------------------------
 2B0                                            ; Procedure:   swap_operands()
 2B0                                            ;
 2B0                                            ; Registers Used: Bank0 : None
 2B0                                            ;     Bank1 : All
 2B0                                            ;
 2B0                                            ; Arguments:   Bank0 : None
 2B0                                            ;     Bank1 : None
 2B0                                            ;
 2B0                                            ; Calls:    None
 2B0                                            ;
 2B0                                            ; RETs:    None
 2B0                                            ;
 2B0                                            ; RETURN Flags:   None
 2B0                                            ;
 2B0                                            ; Description:  Loads two sample operands into SPM for performing arithmatic
 2B0                                            ;     operations on them in test environment.
 2B0                                            ;------------------------------------------------------------------------------------
 2B0                             swap_operands: 
 2B0  37001                                     REGBANK B
 2B1  0B700                                     FETCH s7, 00[x_7]
 2B2  0B601                                     FETCH s6, 01[x_6]
 2B3  0B502                                     FETCH s5, 02[x_5]
 2B4  0B403                                     FETCH s4, 03[x_4]
 2B5  0B304                                     FETCH s3, 04[x_3]
 2B6  0B205                                     FETCH s2, 05[x_2]
 2B7  0B106                                     FETCH s1, 06[x_1]
 2B8  0B007                                     FETCH s0, 07[x_0]
 2B9  0B822                                     FETCH s8, 22[x_grs]
 2BA  0BF08                                     FETCH sF, 08[y_7]
 2BB  0BE09                                     FETCH sE, 09[y_6]
 2BC  0BD0A                                     FETCH sD, 0A[y_5]
 2BD  0BC0B                                     FETCH sC, 0B[y_4]
 2BE  0BB0C                                     FETCH sB, 0C[y_3]
 2BF  0BA0D                                     FETCH sA, 0D[y_2]
 2C0  0B90E                                     FETCH s9, 0E[y_1]
 2C1  2F708                                     STORE s7, 08[y_7]
 2C2  2F609                                     STORE s6, 09[y_6]
 2C3  2F50A                                     STORE s5, 0A[y_5]
 2C4  2F40B                                     STORE s4, 0B[y_4]
 2C5  2F30C                                     STORE s3, 0C[y_3]
 2C6  2F20D                                     STORE s2, 0D[y_2]
 2C7  2F10E                                     STORE s1, 0E[y_1]
 2C8  0B70F                                     FETCH s7, 0F[y_0]
 2C9  0B62D                                     FETCH s6, 2D[y_grs]
 2CA  2F00F                                     STORE s0, 0F[y_0]
 2CB  2F82D                                     STORE s8, 2D[y_grs]
 2CC  2FF00                                     STORE sF, 00[x_7]
 2CD  2FE01                                     STORE sE, 01[x_6]
 2CE  2FD02                                     STORE sD, 02[x_5]
 2CF  2FC03                                     STORE sC, 03[x_4]
 2D0  2FB04                                     STORE sB, 04[x_3]
 2D1  2FA05                                     STORE sA, 05[x_2]
 2D2  2F906                                     STORE s9, 06[x_1]
 2D3  2F707                                     STORE s7, 07[x_0]
 2D4  2F622                                     STORE s6, 22[x_grs]
 2D5                                            ; Swap the operands' status
 2D5  0B53A                                     FETCH s5, 3A[op1_status]
 2D6  0B63B                                     FETCH s6, 3B[op2_status]
 2D7  2F53B                                     STORE s5, 3B[op2_status]
 2D8  2F63A                                     STORE s6, 3A[op1_status]
 2D9  202FA                                     CALL 2FA[decompose_x]
 2DA  20324                                     CALL 324[decompose_y]
 2DB  37000                                     REGBANK A
 2DC  25000                                     RETURN 
 2DD                                            ;------------------------------------------------------------------------------------
 2DD                                            ; Procedure:  count_nlz()
 2DD                                            ; Registers Used:
 2DD                                            ;        Bank0 : s8, s9
 2DD                                            ;    Bank1 : None
 2DD                                            ;
 2DD                                            ; Arguments:
 2DD                                            ;     Bank0 : s8
 2DD                                            ;    Bank1 : None
 2DD                                            ;
 2DD                                            ; Calls:   None
 2DD                                            ;
 2DD                                            ; RETs:   s9: number of leading zeros
 2DD                                            ;
 2DD                                            ; RETURN Flags:  None
 2DD                                            ;
 2DD                                            ; Description: Counts the number of leading zeros in a byte given in s8.
 2DD                                            ;------------------------------------------------------------------------------------
 2DD                                 count_nlz: 
 2DD  01900                                     LOAD s9, 00
 2DE                            count_mlz_loop: 
 2DE  14807                                     SL1 s8
 2DF  3A2E2                                     JUMP C, 2E2[counting_z_done]
 2E0  11901                                     ADD s9, 01                                     ; Increament z by 1
 2E1  222DE                                     JUMP 2DE[count_mlz_loop]
 2E2                           counting_z_done: 
 2E2  25000                                     RETURN 
 2E3                                            ;------------------------------------------------------------------------------------
 2E3                                            ; Procedure:  round()
 2E3                                            ;
 2E3                                            ; Registers Used: Bank0 : s8
 2E3                                            ;     Bank1 : None
 2E3                                            ;
 2E3                                            ; Arguments:   Bank0 : [s1,s0]
 2E3                                            ;     Bank1 : None
 2E3                                            ;
 2E3                                            ; Calls:    None
 2E3                                            ;
 2E3                                            ; RETs:    None
 2E3                                            ;
 2E3                                            ; RETURN Flags:   None
 2E3                                            ;
 2E3                                            ; Description:  This procedure receives guard-sticky-round bits in s0 register
 2E3                                            ;    and RETs 0 or 1 in s0 based on rounding algorith. s1 hold the
 2E3                                            ;   Least signifficant byte.
 2E3                                            ;
 2E3                                            ;
 2E3                                            ; Check the guard bit
 2E3                                            ;  If Gaurd bit = 0 : Round down (Do nothing - simple truncation)
 2E3                                            ;  If Gaurd bit = 1, Check the Round bit
 2E3                                            ; If Gaurd bit = 1, and Round bit = 1 : Round Up (add 1 to mantissa)
 2E3                                            ; If Gaurd bit = 1, and Round bit = 0 : Check the Sticky bit
 2E3                                            ; If Gaurd bit = 1, and Round bit = 0 , and Sticky bit = 1 : Round Up (add 1 to mantissa)
 2E3                                            ; If Gaurd bit = 1, and Round bit = 0 , and Sticky bit = 0 : Round to nearest even.
 2E3                                            ;    Means round up if bitbefore Guard bit is 1, else round down.
 2E3                                            ;------------------------------------------------------------------------------------
 2E3                                     round: 
 2E3                                            ; -------------------------------------------------
 2E3                                            ; Rounding:
 2E3                                            ; Check the guard bit - s0[7]
 2E3  0D080                                     TEST s0, 80
 2E4  362E6                                     JUMP NZ, 2E6[guard_bit_is_1]
 2E5                                            ; Gaurd bit = 0 : Round down (Do  nothing)
 2E5  222F0                                     JUMP 2F0[round_RET_zero]
 2E6                            guard_bit_is_1: 
 2E6                                            ; Gaurd bit = 1, Check the round bit
 2E6  0D040                                     TEST s0, 40
 2E7  322E9                                     JUMP Z, 2E9[round_bit_is_0]
 2E8                                            ; Gaurd bit = 1, Round bit = 1 : Round Up (add 1 to mantissa)
 2E8  222ED                                     JUMP 2ED[round_RET_one]
 2E9                            round_bit_is_0: 
 2E9                                            ; Gaurd bit = 1, Round bit = 0 : Check the Sticky bit
 2E9  0D020                                     TEST s0, 20
 2EA  362ED                                     JUMP NZ, 2ED[round_RET_one]                    ; Gaurd bit = 1, Round bit = 0 , Sticky bit = 1 : Round Up (add 1 to mantissa)
 2EB                                            ; Gaurd bit = 1, Round bit = 0 , Sticky bit = 0 : Round to nearest even,
 2EB                                            ;       Means round up if bit before Guard bit is 1, else round down.
 2EB  0D101                                     TEST s1, 01
 2EC  322F0                                     JUMP Z, 2F0[round_RET_zero]
 2ED                             round_RET_one: 
 2ED                                            ; To prevent double round up we  will zero the grs bits
 2ED  01000                                     LOAD s0, 00                                    ; s0 holing the grs bits of the result
 2EE  01801                                     LOAD s8, 01
 2EF  222F2                                     JUMP 2F2[apply_rounding]
 2F0                            round_RET_zero: 
 2F0                                            ; To prevent double round up we  will zero the grs bits
 2F0  01000                                     LOAD s0, 00                                    ; s0 holing the grs bits of the result
 2F1  01800                                     LOAD s8, 00
 2F2                            apply_rounding: 
 2F2                                            ; Apply rounding
 2F2  10180                                     ADD s1, s8
 2F3  13200                                     ADDCY s2, 00
 2F4  13300                                     ADDCY s3, 00
 2F5  13400                                     ADDCY s4, 00
 2F6  13500                                     ADDCY s5, 00
 2F7  13600                                     ADDCY s6, 00
 2F8  13700                                     ADDCY s7, 00
 2F9  25000                                     RETURN 
 2FA                                            ;------------------------------------------------------------------------------------
 2FA                                            ; Procedure:   normalize()
 2FA                                            ;
 2FA                                            ; Registers Used: Bank0 :
 2FA                                            ;     Bank1 : None
 2FA                                            ;
 2FA                                            ; Arguments:   Bank0 :
 2FA                                            ;     Bank1 : None
 2FA                                            ;
 2FA                                            ; Calls:    None
 2FA                                            ;
 2FA                                            ; RETs:    None
 2FA                                            ;
 2FA                                            ; RETURN Flags:   None
 2FA                                            ;
 2FA                                            ; Description:  Normalizes a given number
 2FA                                            ;------------------------------------------------------------------------------------
 2FA                                            ;------------------------------------------------------------------------------------
 2FA                                            ; Procedure:   decompose_x()
 2FA                                            ;
 2FA                                            ; Registers Used: Bank0 : s7, s6, ..., s0
 2FA                                            ;     Bank1 : None
 2FA                                            ;
 2FA                                            ; Arguments:   Bank0 : None
 2FA                                            ;     Bank1 : None
 2FA                                            ;     SPM   : x_7, x_6, ..., x_0
 2FA                                            ;
 2FA                                            ; Calls:    None
 2FA                                            ;
 2FA                                            ; RETs:    None
 2FA                                            ;
 2FA                                            ; RETURN Flags:   None
 2FA                                            ;
 2FA                                            ; Description:  Extracts sign, exonent, and mantisa from given 64-bit number
 2FA                                            ;------------------------------------------------------------------------------------
 2FA                               decompose_x: 
 2FA  0B700                                     FETCH s7, 00[x_7]
 2FB  0D780                                     TEST s7, 80
 2FC  362FF                                     JUMP NZ, 2FF[negative_sign_x]
 2FD  01000                                     LOAD s0, 00                                    ; positive = 00
 2FE  22300                                     JUMP 300[test_x_sign_done]
 2FF                           negative_sign_x: 
 2FF  01080                                     LOAD s0, 80                                    ; positive = 80
 300                          test_x_sign_done: 
 300  2F018                                     STORE s0, 18[x_sign]                           ; set the sign
 301  0B601                                     FETCH s6, 01[x_6]
 302  0377F                                     AND s7, 7F                                     ; Zero the sign bit
 303                                            ; Shift right by 4 bits to remove the 4-bits of mantisa on the low
 303                                            ; nibble of s6.
 303  1470E                                     SR0 s7
 304  14608                                     SRA s6
 305  1470E                                     SR0 s7
 306  14608                                     SRA s6
 307  1470E                                     SR0 s7
 308  14608                                     SRA s6
 309  1470E                                     SR0 s7
 30A  14608                                     SRA s6
 30B                                            ; Save extracted exponent in SPM
 30B  2F719                                     STORE s7, 19[x_ex7]
 30C  2F61A                                     STORE s6, 1A[x_ex6]
 30D                                            ;Is x subnormal? yes: inject hidden 0, No: Inject hidden 1
 30D  0B03A                                     FETCH s0, 3A[op1_status]
 30E  0D080                                     TEST s0, 80
 30F  36312                                     JUMP NZ, 312[subnormal_involved_x]
 310                                            ; not a subnormal
 310  01010                                     LOAD s0, 10
 311  22313                                     JUMP 313[subnormal_test_done_x]
 312                      subnormal_involved_x: 
 312  01000                                     LOAD s0, 00
 313                     subnormal_test_done_x: 
 313  0B601                                     FETCH s6, 01[x_6]                              ; Recover bit no 6
 314  0360F                                     AND s6, 0F                                     ; Zero the high nibble
 315  04600                                     OR s6, s0
 316  2F61B                                     STORE s6, 1B[x_m6]                             ; Save extracted mantisa in SPM
 317  0B502                                     FETCH s5, 02[x_5]
 318  0B403                                     FETCH s4, 03[x_4]
 319  0B304                                     FETCH s3, 04[x_3]
 31A  0B205                                     FETCH s2, 05[x_2]
 31B  0B106                                     FETCH s1, 06[x_1]
 31C  0B007                                     FETCH s0, 07[x_0]
 31D  2F51C                                     STORE s5, 1C[x_m5]
 31E  2F41D                                     STORE s4, 1D[x_m4]
 31F  2F31E                                     STORE s3, 1E[x_m3]
 320  2F21F                                     STORE s2, 1F[x_m2]
 321  2F120                                     STORE s1, 20[x_m1]
 322  2F021                                     STORE s0, 21[x_m0]
 323  25000                                     RETURN 
 324                                            ;------------------------------------------------------------------------------------
 324                                            ; Procedure:   decompose_y()
 324                                            ;
 324                                            ; Registers Used: Bank0 : sF, sE, ..., s8
 324                                            ;     Bank1 : None
 324                                            ;
 324                                            ; Arguments:   Bank0 : None
 324                                            ;     Bank1 : None
 324                                            ;     SPM   : y_7, y_6, ..., y_0
 324                                            ;
 324                                            ; Calls:    None
 324                                            ;
 324                                            ; RETs:    None
 324                                            ;
 324                                            ; RETURN Flags:   None
 324                                            ;
 324                                            ; Description:  Extracts sign, exonent, and mantisa from given 64-bit number
 324                                            ;------------------------------------------------------------------------------------
 324                               decompose_y: 
 324  0B708                                     FETCH s7, 08[y_7]
 325  0D780                                     TEST s7, 80
 326  36329                                     JUMP NZ, 329[negative_sign_y]
 327                           positive_sign_y: 
 327  01000                                     LOAD s0, 00                                    ; positive = 00
 328  2232A                                     JUMP 32A[test_y_sign_done]
 329                           negative_sign_y: 
 329  01080                                     LOAD s0, 80                                    ; positive = 80
 32A                          test_y_sign_done: 
 32A  2F023                                     STORE s0, 23[y_sign]                           ; set the sign
 32B  0B609                                     FETCH s6, 09[y_6]
 32C  0377F                                     AND s7, 7F                                     ; Zero the sign bit
 32D                                            ; Shift right by 4 bits to remove the 4-bits of mantisa on the low
 32D                                            ; nibble of s6.
 32D  1470E                                     SR0 s7
 32E  14608                                     SRA s6
 32F  1470E                                     SR0 s7
 330  14608                                     SRA s6
 331  1470E                                     SR0 s7
 332  14608                                     SRA s6
 333  1470E                                     SR0 s7
 334  14608                                     SRA s6
 335                                            ; Save extracted exponent in SPM
 335  2F724                                     STORE s7, 24[y_ex7]
 336  2F625                                     STORE s6, 25[y_ex6]
 337                                            ;Is x subnormal? yes: inject hidden 0, No: Inject hidden 1
 337  0B03B                                     FETCH s0, 3B[op2_status]
 338  0D080                                     TEST s0, 80
 339  3633C                                     JUMP NZ, 33C[subnormal_involved_y]
 33A                                            ; not a subnormal
 33A  01010                                     LOAD s0, 10
 33B  2233D                                     JUMP 33D[subnormal_test_done_y]
 33C                      subnormal_involved_y: 
 33C  01000                                     LOAD s0, 00
 33D                     subnormal_test_done_y: 
 33D  0B609                                     FETCH s6, 09[y_6]                              ; Recover bit no 6
 33E  0360F                                     AND s6, 0F                                     ; Zero the high nibble
 33F  04600                                     OR s6, s0
 340  2F626                                     STORE s6, 26[y_m6]                             ; Save extracted mantisa in SPM
 341  0B50A                                     FETCH s5, 0A[y_5]
 342  0B40B                                     FETCH s4, 0B[y_4]
 343  0B30C                                     FETCH s3, 0C[y_3]
 344  0B20D                                     FETCH s2, 0D[y_2]
 345  0B10E                                     FETCH s1, 0E[y_1]
 346  0B00F                                     FETCH s0, 0F[y_0]
 347  2F527                                     STORE s5, 27[y_m5]
 348  2F428                                     STORE s4, 28[y_m4]
 349  2F329                                     STORE s3, 29[y_m3]
 34A  2F22A                                     STORE s2, 2A[y_m2]
 34B  2F12B                                     STORE s1, 2B[y_m1]
 34C  2F02C                                     STORE s0, 2C[y_m0]
 34D  25000                                     RETURN 
 34E                                            ;------------------------------------------------------------------------------------
 34E                                            ; Procedure:   set_ops_status()
 34E                                            ;
 34E                                            ; Registers Used: Bank0 :
 34E                                            ;     Bank1 : None
 34E                                            ;     SPM   : x_7, x_6, y_7, y_6
 34E                                            ;
 34E                                            ; Arguments:   Bank0 :
 34E                                            ;     Bank1 : None
 34E                                            ;
 34E                                            ; Calls:    None
 34E                                            ;     None
 34E                                            ;
 34E                                            ; RETs:    SPM:
 34E                                            ;      op1_status
 34E                                            ;       op2_status
 34E                                            ;
 34E                                            ; RETURN Flags:   None
 34E                                            ;
 34E                                            ; Description:  Set op1 and op2 status flags: Check for subnormals, zeros,
 34E                                            ;      NaNs and infinities.
 34E                                            ;------------------------------------------------------------------------------------
 34E                            set_ops_status: 
 34E                                            ; Check if the op1 (ex) exponent bits subnormalare all zero
 34E                                            ; Extract ex : [s7, s6]
 34E  0B700                                     FETCH s7, 00[x_7]
 34F  0B601                                     FETCH s6, 01[x_6]
 350  0377F                                     AND s7, 7F                                     ; zero the sign bit
 351  0D6F0                                     TEST s6, F0
 352  0F77F                                     TESTCY s7, 7F
 353  36373                                     JUMP NZ, 373[ex_not_zero]
 354                                   ex_zero: 
 354                                            ; Load x mantisa into registers
 354  0B601                                     FETCH s6, 01[x_6]
 355  0B502                                     FETCH s5, 02[x_5]
 356  0B403                                     FETCH s4, 03[x_4]
 357  0B304                                     FETCH s3, 04[x_3]
 358  0B205                                     FETCH s2, 05[x_2]
 359  0B106                                     FETCH s1, 06[x_1]
 35A  0B007                                     FETCH s0, 07[x_0]
 35B  0D60F                                     TEST s6, 0F
 35C  0F5FF                                     TESTCY s5, FF
 35D  0F4FF                                     TESTCY s4, FF
 35E  0F3FF                                     TESTCY s3, FF
 35F  0F2FF                                     TESTCY s2, FF
 360  0F1FF                                     TESTCY s1, FF
 361  0F0FF                                     TESTCY s0, FF
 362  3636F                                     JUMP NZ, 36F[op1_is_subnormal]
 363  1490E                                     SR0 s9                                         ; Shift to right by 4
 364  14808                                     SRA s8
 365  1490E                                     SR0 s9
 366  14808                                     SRA s8
 367  1490E                                     SR0 s9
 368  14808                                     SRA s8
 369  1490E                                     SR0 s9
 36A  14808                                     SRA s8
 36B                              op_1_is_zero: 
 36B                                            ; set op1 status flag to "Zero"   -- status bits = SZIN
 36B  0B03A                                     FETCH s0, 3A[op1_status]
 36C  05040                                     OR s0, 40                                      ; op1 is zero
 36D  2F03A                                     STORE s0, 3A[op1_status]
 36E  22394                                     JUMP 394[set_op2_status]
 36F                          op1_is_subnormal: 
 36F                                            ; set op1 status flag to "Subnormal"
 36F  0B03A                                     FETCH s0, 3A[op1_status]
 370  05080                                     OR s0, 80                                      ; op1 is subnormal
 371  2F03A                                     STORE s0, 3A[op1_status]
 372  22394                                     JUMP 394[set_op2_status]
 373                               ex_not_zero: 
 373                                            ; Check if the op1 (ex) exponent bits are all one
 373                                            ; Extract ex : [s7, s6]
 373  0B700                                     FETCH s7, 00[x_7]
 374  0B601                                     FETCH s6, 01[x_6]
 375  0377F                                     AND s7, 7F                                     ; zero the sign bit
 376  036F0                                     AND s6, F0                                     ; zero the low nibble
 377  1D6F0                                     COMPARE s6, F0
 378  1F77F                                     COMPARECY s7, 7F
 379  36391                                     JUMP NZ, 391[ex_not_all_one]
 37A                                ex_all_one: 
 37A                                            ; Load x mantisa into registers
 37A  0B601                                     FETCH s6, 01[x_6]
 37B  0B502                                     FETCH s5, 02[x_5]
 37C  0B403                                     FETCH s4, 03[x_4]
 37D  0B304                                     FETCH s3, 04[x_3]
 37E  0B205                                     FETCH s2, 05[x_2]
 37F  0B106                                     FETCH s1, 06[x_1]
 380  0B007                                     FETCH s0, 07[x_0]
 381                                            ; Check if all bits of significand are zero
 381  0D60F                                     TEST s6, 0F
 382  0F5FF                                     TESTCY s5, FF
 383  0F4FF                                     TESTCY s4, FF
 384  0F3FF                                     TESTCY s3, FF
 385  0F2FF                                     TESTCY s2, FF
 386  0F1FF                                     TESTCY s1, FF
 387  0F0FF                                     TESTCY s0, FF
 388  3238D                                     JUMP Z, 38D[op1_is_inf]
 389                                op1_is_NaN: 
 389                                            ; set op1 status flag to "NaN" -- status bits = SZIN --
 389  0B03A                                     FETCH s0, 3A[op1_status]
 38A  05010                                     OR s0, 10                                      ; op1 is NaN
 38B  2F03A                                     STORE s0, 3A[op1_status]
 38C  22394                                     JUMP 394[set_op2_status]
 38D                                op1_is_inf: 
 38D                                            ; set op1 status flag to "Infinite"
 38D  0B03A                                     FETCH s0, 3A[op1_status]
 38E  05020                                     OR s0, 20                                      ; op1 is infinite
 38F  2F03A                                     STORE s0, 3A[op1_status]
 390  22394                                     JUMP 394[set_op2_status]
 391                            ex_not_all_one: 
 391                                            ; Here we conclude that ex is not all zeros and not all ones.
 391                                            ;  therefore op1 must be a normal operand.
 391                                            ; set op1 status flag to "Infinite"
 391  0B03A                                     FETCH s0, 3A[op1_status]
 392  05001                                     OR s0, 01                                      ; op1 is normal
 393  2F03A                                     STORE s0, 3A[op1_status]
 394                            set_op2_status: 
 394                                            ; Check if the op2 (ey) exponent bits are all zero
 394                                            ; Extract ex : [s7, s6]
 394  0B708                                     FETCH s7, 08[y_7]
 395  0B609                                     FETCH s6, 09[y_6]
 396  0377F                                     AND s7, 7F                                     ; zero the sign bit
 397  0D6F0                                     TEST s6, F0
 398  0F77F                                     TESTCY s7, 7F
 399  363B1                                     JUMP NZ, 3B1[ey_not_zero]
 39A                                   ey_zero: 
 39A                                            ; Load y mantisa into registers
 39A  0BF09                                     FETCH sF, 09[y_6]
 39B  0BE0A                                     FETCH sE, 0A[y_5]
 39C  0BD0B                                     FETCH sD, 0B[y_4]
 39D  0BC0C                                     FETCH sC, 0C[y_3]
 39E  0BB0D                                     FETCH sB, 0D[y_2]
 39F  0BA0E                                     FETCH sA, 0E[y_1]
 3A0  0B90F                                     FETCH s9, 0F[y_0]
 3A1                                            ; Check if all bits of significand are zero
 3A1  0DF0F                                     TEST sF, 0F
 3A2  0FEFF                                     TESTCY sE, FF
 3A3  0FDFF                                     TESTCY sD, FF
 3A4  0FCFF                                     TESTCY sC, FF
 3A5  0FBFF                                     TESTCY sB, FF
 3A6  0FAFF                                     TESTCY sA, FF
 3A7  0F9FF                                     TESTCY s9, FF
 3A8  363AD                                     JUMP NZ, 3AD[op2_is_subnormal]
 3A9                              op_2_is_zero: 
 3A9                                            ; set op1 status flag to "Zero"   -- status bits = SZIN --
 3A9  0B03B                                     FETCH s0, 3B[op2_status]
 3AA  05040                                     OR s0, 40                                      ; op2 is zero
 3AB  2F03B                                     STORE s0, 3B[op2_status]
 3AC  25000                                     RETURN 
 3AD                          op2_is_subnormal: 
 3AD                                            ; set op1 status flag to "Subnormal"
 3AD  0B03B                                     FETCH s0, 3B[op2_status]
 3AE  05080                                     OR s0, 80                                      ; op1 is subnormal
 3AF  2F03B                                     STORE s0, 3B[op2_status]
 3B0  25000                                     RETURN 
 3B1                               ey_not_zero: 
 3B1                                            ; Check if the op2 (ex) exponent bits are all one
 3B1                                            ; Extract ex : [s7, s6]
 3B1  0B708                                     FETCH s7, 08[y_7]
 3B2  0B609                                     FETCH s6, 09[y_6]
 3B3  0377F                                     AND s7, 7F                                     ; zero the sign bit
 3B4  036F0                                     AND s6, F0                                     ; zero the low nibble
 3B5  1D6F0                                     COMPARE s6, F0
 3B6  1F77F                                     COMPARECY s7, 7F
 3B7  363CF                                     JUMP NZ, 3CF[ey_not_all_one]
 3B8                                ey_all_one: 
 3B8                                            ; Load y mantisa into registers
 3B8  0BF09                                     FETCH sF, 09[y_6]
 3B9  0BE0A                                     FETCH sE, 0A[y_5]
 3BA  0BD0B                                     FETCH sD, 0B[y_4]
 3BB  0BC0C                                     FETCH sC, 0C[y_3]
 3BC  0BB0D                                     FETCH sB, 0D[y_2]
 3BD  0BA0E                                     FETCH sA, 0E[y_1]
 3BE  0B90F                                     FETCH s9, 0F[y_0]
 3BF                                            ; Check if all bits of significand are zero
 3BF  0DF0F                                     TEST sF, 0F
 3C0  0FEFF                                     TESTCY sE, FF
 3C1  0FDFF                                     TESTCY sD, FF
 3C2  0FCFF                                     TESTCY sC, FF
 3C3  0FBFF                                     TESTCY sB, FF
 3C4  0FAFF                                     TESTCY sA, FF
 3C5  0F9FF                                     TESTCY s9, FF
 3C6  323CB                                     JUMP Z, 3CB[op2_is_inf]
 3C7                                op2_is_NaN: 
 3C7                                            ; set op1 status flag to "NaN" -- status bits = SZIN --
 3C7  0B03B                                     FETCH s0, 3B[op2_status]
 3C8  05010                                     OR s0, 10                                      ; op1 is NaN
 3C9  2F03B                                     STORE s0, 3B[op2_status]
 3CA  25000                                     RETURN 
 3CB                                op2_is_inf: 
 3CB                                            ; set op1 status flag to "Infinite"
 3CB  0B03B                                     FETCH s0, 3B[op2_status]
 3CC  05020                                     OR s0, 20                                      ; op1 is infinite
 3CD  2F03B                                     STORE s0, 3B[op2_status]
 3CE  25000                                     RETURN 
 3CF                            ey_not_all_one: 
 3CF                                            ; Here we conclude that ey is not all zeros and not all ones.
 3CF                                            ;  therefore op1 must be a normal operand.
 3CF  0B03B                                     FETCH s0, 3B[op2_status]
 3D0  05001                                     OR s0, 01                                      ; op2 is normal
 3D1  2F03B                                     STORE s0, 3B[op2_status]
 3D2  25000                                     RETURN 
 3D3                                            ;------------------------------------------------------------------------------------
 3D3                                            ; Procedure:   twos_mx()
 3D3                                            ;
 3D3                                            ; Registers Used: Bank0 :
 3D3                                            ;     Bank1 : None
 3D3                                            ;     SPM   : x_m7, x_m6, ... x_m0
 3D3                                            ;
 3D3                                            ; Arguments:   Bank0 :
 3D3                                            ;     Bank1 : None
 3D3                                            ;
 3D3                                            ; Calls:    None
 3D3                                            ;     None
 3D3                                            ;
 3D3                                            ; RETs:    SPM:
 3D3                                            ;
 3D3                                            ; RETURN Flags:   None
 3D3                                            ;
 3D3                                            ; Description:  Calcultes the twos complement of mx and replace it
 3D3                                            ;      with the result
 3D3                                            ;------------------------------------------------------------------------------------
 3D3                                   twos_mx: 
 3D3  2029E                                     CALL 29E[load_mx]                              ; Load hidden bit+mantisa+guard bits(grs) [s7, s0]
 3D4  070E0                                     XOR s0, E0                                     ; toggle all bits
 3D5  071FF                                     XOR s1, FF
 3D6  072FF                                     XOR s2, FF
 3D7  073FF                                     XOR s3, FF
 3D8  074FF                                     XOR s4, FF
 3D9  075FF                                     XOR s5, FF
 3DA  076FF                                     XOR s6, FF
 3DB  0777F                                     XOR s7, 7F
 3DC  11020                                     ADD s0, 20                                     ; Add 1 to the sticky bit
 3DD  13100                                     ADDCY s1, 00
 3DE  13200                                     ADDCY s2, 00
 3DF  13300                                     ADDCY s3, 00
 3E0  13400                                     ADDCY s4, 00
 3E1  13500                                     ADDCY s5, 00
 3E2  13600                                     ADDCY s6, 00
 3E3  13700                                     ADDCY s7, 00
 3E4  2F71B                                     STORE s7, 1B[x_m6]                             ; Save back the shifted mantisa into SPM
 3E5  2F61C                                     STORE s6, 1C[x_m5]
 3E6  2F51D                                     STORE s5, 1D[x_m4]
 3E7  2F41E                                     STORE s4, 1E[x_m3]
 3E8  2F31F                                     STORE s3, 1F[x_m2]
 3E9  2F220                                     STORE s2, 20[x_m1]
 3EA  2F121                                     STORE s1, 21[x_m0]
 3EB  2F022                                     STORE s0, 22[x_grs]
 3EC  25000                                     RETURN 
 3ED                                            ;------------------------------------------------------------------------------------
 3ED                                            ; Procedure:   twos_my()
 3ED                                            ;
 3ED                                            ; Registers Used: Bank0 :
 3ED                                            ;     Bank1 : None
 3ED                                            ;     SPM   : x_m7, x_m6, ... x_m0
 3ED                                            ;
 3ED                                            ; Arguments:   Bank0 :
 3ED                                            ;     Bank1 : None
 3ED                                            ;
 3ED                                            ; Calls:    None
 3ED                                            ;     None
 3ED                                            ;
 3ED                                            ; RETs:    SPM:
 3ED                                            ;
 3ED                                            ; RETURN Flags:   None
 3ED                                            ;
 3ED                                            ; Description:  Calcultes the twos complement of my and replace it
 3ED                                            ;      with the result
 3ED                                            ;------------------------------------------------------------------------------------
 3ED                                   twos_my: 
 3ED  202A7                                     CALL 2A7[load_my]                              ; Load hidden bit+mantisa+guard bits(grs) [sF, s8]
 3EE  078E0                                     XOR s8, E0                                     ; toggle all bits
 3EF  079FF                                     XOR s9, FF
 3F0  07AFF                                     XOR sA, FF
 3F1  07BFF                                     XOR sB, FF
 3F2  07CFF                                     XOR sC, FF
 3F3  07DFF                                     XOR sD, FF
 3F4  07EFF                                     XOR sE, FF
 3F5  07F7F                                     XOR sF, 7F
 3F6  11820                                     ADD s8, 20                                     ; Add 1 to the sticky bit
 3F7  13900                                     ADDCY s9, 00
 3F8  13A00                                     ADDCY sA, 00
 3F9  13B00                                     ADDCY sB, 00
 3FA  13C00                                     ADDCY sC, 00
 3FB  13D00                                     ADDCY sD, 00
 3FC  13E00                                     ADDCY sE, 00
 3FD  13F00                                     ADDCY sF, 00
 3FE  2FF26                                     STORE sF, 26[y_m6]                             ; Save back the shifted mantisa into SPM
 3FF  2FE27                                     STORE sE, 27[y_m5]
 400  2FD28                                     STORE sD, 28[y_m4]
 401  2FC29                                     STORE sC, 29[y_m3]
 402  2FB2A                                     STORE sB, 2A[y_m2]
 403  2FA2B                                     STORE sA, 2B[y_m1]
 404  2F92C                                     STORE s9, 2C[y_m0]
 405  2F82D                                     STORE s8, 2D[y_grs]
 406  25000                                     RETURN 
 407                                            ;------------------------------------------------------------------------------------
 407                                            ; Procedure:   normalize()
 407                                            ;
 407                                            ; Registers Used: Bank0 : s7, s6, ..., s0: Hidden bit + mantisa + guard bits (grs)
 407                                            ;     Bank1 : None
 407                                            ;
 407                                            ; Arguments:   Bank0 : s7, s6, ..., s0: Hidden bit + mantisa + guard bits (grs)
 407                                            ;     Bank1 : None
 407                                            ;
 407                                            ; Calls:    None
 407                                            ;     None
 407                                            ;
 407                                            ; RETs:    SPM:
 407                                            ;
 407                                            ; RETURN Flags:   None
 407                                            ;
 407                                            ; Description:  Normalized the result saved in [s7, s6, ..., s0].
 407                                            ;------------------------------------------------------------------------------------
 407                                 normalize: 
 407  0D720                                     TEST s7, 20
 408  3241E                                     JUMP Z, 41E[no_overflow_found]
 409                                            ; Overflow detected
 409                                            ; if sticky bit of s0 is 1 keep it 1
 409  0D020                                     TEST s0, 20
 40A  3240D                                     JUMP Z, 40D[dont_keep_sticky_bit]
 40B  01F20                                     LOAD sF, 20
 40C  2240E                                     JUMP 40E[done_keeping_sticky_bit]
 40D                      dont_keep_sticky_bit: 
 40D  01F00                                     LOAD sF, 00
 40E                   done_keeping_sticky_bit: 
 40E  1470E                                     SR0 s7                                         ; shift left by 1
 40F  14608                                     SRA s6
 410  14508                                     SRA s5
 411  14408                                     SRA s4
 412  14308                                     SRA s3
 413  14208                                     SRA s2
 414  14108                                     SRA s1
 415  14008                                     SRA s0
 416  0B830                                     FETCH s8, 30[r_ex6]                            ; Yes: Increment exponent by 1
 417  0B92F                                     FETCH s9, 2F[r_ex7]
 418  11801                                     ADD s8, 01
 419  13900                                     ADDCY s9, 00
 41A  2F830                                     STORE s8, 30[r_ex6]
 41B  2F92F                                     STORE s9, 2F[r_ex7]
 41C  040F0                                     OR s0, sF
 41D  2248D                                     JUMP 48D[done_cancellation]
 41E                         no_overflow_found: 
 41E                                            ; Check if we need normalization or not
 41E  0D710                                     TEST s7, 10
 41F  32431                                     JUMP Z, 431[cancellation]                      ; Perform cancellation
 420                                            ; JUMP NZ, done_cancellation ; Perform cancellation
 420                      check_subnormal_case: 
 420                                            ; Check if both operands are subnormals
 420  0BF3A                                     FETCH sF, 3A[op1_status]
 421  0BE3B                                     FETCH sE, 3B[op2_status]
 422  02FE0                                     AND sF, sE
 423  0DF80                                     TEST sF, 80
 424  3248D                                     JUMP Z, 48D[done_cancellation]
 425                                            ; Both ops subnormal but bit4 of s7 is 1 => underflow detected
 425  0B83C                                     FETCH s8, 3C[underflow]
 426  0D801                                     TEST s8, 01
 427  3648D                                     JUMP NZ, 48D[done_cancellation]                ; underflow already applied
 428                                            ; Both subnormals but we have 1 in bit 1 of s7 =< apply underflow
 428  0B830                                     FETCH s8, 30[r_ex6]                            ; Increment exponent by 1
 429  0B92F                                     FETCH s9, 2F[r_ex7]
 42A  11801                                     ADD s8, 01
 42B  13900                                     ADDCY s9, 00
 42C  2F830                                     STORE s8, 30[r_ex6]
 42D  2F92F                                     STORE s9, 2F[r_ex7]
 42E  01801                                     LOAD s8, 01                                    ; Set underflow applied bit
 42F  2F83C                                     STORE s8, 3C[underflow]
 430  2248D                                     JUMP 48D[done_cancellation]
 431                              cancellation: 
 431                                            ; Cancellation:
 431                                            ; Count the number of leading zeros = nlz
 431                                            ; Shift "mr" left by nlz, and set er = er - nlz
 431                                            ; Check if er is zero then the result is as it is
 431  0BB2F                                     FETCH sB, 2F[r_ex7]
 432  0BA30                                     FETCH sA, 30[r_ex6]
 433  0DA0F                                     TEST sA, 0F
 434  0FBFF                                     TESTCY sB, FF
 435  3248D                                     JUMP Z, 48D[done_cancellation]                 ; result is subnormal
 436                                            ; else perform cancellation
 436  01A01                                     LOAD sA, 01                                    ; nlz nounter
 437                                            ; zero the unused bit
 437  0377F                                     AND s7, 7F
 438  00870                                     LOAD s8, s7                                    ; make a copy of s7
 439  14807                                     SL1 s8
 43A  14807                                     SL1 s8
 43B  14807                                     SL1 s8
 43C  14807                                     SL1 s8
 43D                                            ; Count nlz in s8
 43D  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 43E  0D9FF                                     TEST s9, FF                                    ; is s9 = 0 ?
 43F  3246B                                     JUMP Z, 46B[nlz_counting_done]
 440  1D904                                     COMPARE s9, 04
 441  32444                                     JUMP Z, 444[got_nlz_4]
 442  10A90                                     ADD sA, s9                                     ; Less than 4 zeros, Add the counted nlz to sA
 443                                            ;  and finish the nlz counting,
 443  2246B                                     JUMP 46B[nlz_counting_done]
 444                                 got_nlz_4: 
 444  11A04                                     ADD sA, 04                                     ; Add 4 nlz to sA
 445  00860                                     LOAD s8, s6
 446  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 447  1D908                                     COMPARE s9, 08
 448  3244B                                     JUMP Z, 44B[got_nlz_8]
 449  10A90                                     ADD sA, s9                                     ; Less than 8 zeros, Add the counted nlz to sA
 44A                                            ;  and finish the nlz counting,
 44A  2246B                                     JUMP 46B[nlz_counting_done]
 44B                                 got_nlz_8: 
 44B  11A08                                     ADD sA, 08                                     ; Add 8 nlz to sA
 44C  00850                                     LOAD s8, s5
 44D  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 44E  1D908                                     COMPARE s9, 08
 44F  32452                                     JUMP Z, 452[got_nlz_8_s5]
 450  10A90                                     ADD sA, s9                                     ; Less than 4 zeros, Add the counted nlz to sA
 451                                            ;  and finish the nlz counting,
 451  2246B                                     JUMP 46B[nlz_counting_done]
 452                              got_nlz_8_s5: 
 452  11A08                                     ADD sA, 08                                     ; Add 8 nlz to sA
 453  00840                                     LOAD s8, s4
 454  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 455  1D908                                     COMPARE s9, 08
 456  32459                                     JUMP Z, 459[got_nlz_8_s4]
 457  10A90                                     ADD sA, s9                                     ; Less than 8 zeros, Add the counted nlz to sA
 458                                            ;  and finish the nlz counting,
 458  2246B                                     JUMP 46B[nlz_counting_done]
 459                              got_nlz_8_s4: 
 459  11A08                                     ADD sA, 08                                     ; Add 8 nlz to sA
 45A  00830                                     LOAD s8, s3
 45B  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 45C  1D908                                     COMPARE s9, 08
 45D  32460                                     JUMP Z, 460[got_nlz_8_s3]
 45E  10A90                                     ADD sA, s9                                     ; Less than 8 zeros, Add the counted nlz to sA
 45F                                            ;  and finish the nlz counting,
 45F  2246B                                     JUMP 46B[nlz_counting_done]
 460                              got_nlz_8_s3: 
 460  11A08                                     ADD sA, 08                                     ; Add 8 nlz to sA
 461  00820                                     LOAD s8, s2
 462  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 463  1D908                                     COMPARE s9, 08
 464  32467                                     JUMP Z, 467[got_nlz_8_s2]
 465  10A90                                     ADD sA, s9                                     ; Less than 8 zeros, Add the counted nlz to sA
 466                                            ;  and finish the nlz counting,
 466  2246B                                     JUMP 46B[nlz_counting_done]
 467                              got_nlz_8_s2: 
 467  11A08                                     ADD sA, 08                                     ; Add 8 nlz to sA
 468  00810                                     LOAD s8, s1
 469  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 46A  10A90                                     ADD sA, s9                                     ; Less than 8 zeros, Add the counted nlz to sA
 46B                                            ;  and finish the nlz counting,
 46B                         nlz_counting_done: 
 46B  0DAFF                                     TEST sA, FF                                    ; is sA zero ?
 46C  32478                                     JUMP Z, 478[done_intermediate_shift_riht_loop]
 46D                                            ; Shift the intermediate result to left by nlz(sA) bits.
 46D  009A0                                     LOAD s9, sA                                    ; Copy the sA
 46E                                            ; At this point result mantisa is in [s7, s6, ..., s1]
 46E              intermediate_shift_riht_loop: 
 46E  14006                                     SL0 s0                                         ; 1-bit left shift
 46F  14100                                     SLA s1
 470  14200                                     SLA s2
 471  14300                                     SLA s3
 472  14400                                     SLA s4
 473  14500                                     SLA s5
 474  14600                                     SLA s6
 475  14700                                     SLA s7
 476  19901                                     SUB s9, 01
 477  3646E                                     JUMP NZ, 46E[intermediate_shift_riht_loop]
 478         done_intermediate_shift_riht_loop: 
 478                                            ; Subtract the er by the number of bits shifted left (sA).
 478  0B92F                                     FETCH s9, 2F[r_ex7]                            ; read exponent
 479  0B830                                     FETCH s8, 30[r_ex6]
 47A  188A0                                     SUB s8, sA
 47B  1B900                                     SUBCY s9, 00
 47C  2F92F                                     STORE s9, 2F[r_ex7]                            ; write back result exponent
 47D  2F830                                     STORE s8, 30[r_ex6]
 47E  2248D                                     JUMP 48D[done_cancellation]
 47F              normalize_shift_right_by_one: 
 47F  1470E                                     SR0 s7
 480  14608                                     SRA s6
 481  14508                                     SRA s5
 482  14408                                     SRA s4
 483  14308                                     SRA s3
 484  14208                                     SRA s2
 485  14108                                     SRA s1
 486  14008                                     SRA s0
 487  0B92F                                     FETCH s9, 2F[r_ex7]                            ; read exponent
 488  0B830                                     FETCH s8, 30[r_ex6]
 489  11801                                     ADD s8, 01
 48A  13900                                     ADDCY s9, 00
 48B  2F92F                                     STORE s9, 2F[r_ex7]                            ; write back result exponent
 48C  2F830                                     STORE s8, 30[r_ex6]
 48D                         done_cancellation: 
 48D  25000                                     RETURN 
 48E                                            ;-----------------------------------------------------------------------------------
 48E                                            ; Software Implementation of Floating-Point Arithmetic, Double-Precision (64 bit).
 48E                                            ;
 48E                                            ; beta(radix) = 2, k(width) = 64, p(precision) = 53, e_max = 1023
 48E                                            ;
 48E                                            ;------------------------------------------------------------------------------------
 48E                                            ; Procedure:   arith_mul_x_y()
 48E                                            ;
 48E                                            ; Registers Used: Bank0 : All
 48E                                            ;     Bank1 : None
 48E                                            ;
 48E                                            ; Arguments:   Bank0 :
 48E                                            ;     Bank1 : None
 48E                                            ;     SPM   : x = [x_7, x_6, ..., x_0]
 48E                                            ;            y = [y_7, y_6, ..., y_0]
 48E                                            ;
 48E                                            ; Calls:
 48E                                            ;
 48E                                            ; RETs:    None
 48E                                            ;
 48E                                            ; RETURN Flags:   None
 48E                                            ;
 48E                                            ; Description:  Adds two 64-bit double-precision floating point numbers.
 48E                                            ;   This procedure always add. For subtraction set the sign of second  operand
 48E                                            ; to negative due to the fact that x + (-y) = x - y.
 48E                                            ;------------------------------------------------------------------------------------
 48E                             arith_mul_x_y: 
 48E  2034E                                     CALL 34E[set_ops_status]
 48F  202FA                                     CALL 2FA[decompose_x]
 490  20324                                     CALL 324[decompose_y]
 491  20590                                     CALL 590[mul_special_cases]
 492  1DFFF                                     COMPARE sF, FF
 493  324D4                                     JUMP Z, 4D4[done_multiplying]
 494  20602                                     CALL 602[mul_normalize_mx]
 495  20613                                     CALL 613[mul_normalize_my]
 496                                            ; op1 and op2 both are normal
 496  204D5                                     CALL 4D5[mul_mx_my]                            ; result is in [Umr_6, Umr_0]
 497  20587                                     CALL 587[add_ex_ey]                            ; exponent of result in [s1, s0]
 498                                            ; if er < -1023 then underflow has occured: return zero
 498  0D180                                     TEST s1, 80
 499  364D3                                     JUMP NZ, 4D3[mul_result_is_zero]
 49A                                            ; Compose the result
 49A  0B840                                     FETCH s8, 40[Umr_6]
 49B  0B741                                     FETCH s7, 41[Umr_5]
 49C  0B642                                     FETCH s6, 42[Umr_4]
 49D  0B543                                     FETCH s5, 43[Umr_3]
 49E  0B444                                     FETCH s4, 44[Umr_2]
 49F  0B345                                     FETCH s3, 45[Umr_1]
 4A0  0B246                                     FETCH s2, 46[Umr_0]
 4A1                                            ; shif significand result to left by 2
 4A1  14206                                     SL0 s2
 4A2  14300                                     SLA s3
 4A3  14400                                     SLA s4
 4A4  14500                                     SLA s5
 4A5  14600                                     SLA s6
 4A6  14700                                     SLA s7
 4A7  14800                                     SLA s8
 4A8  14206                                     SL0 s2
 4A9  14300                                     SLA s3
 4AA  14400                                     SLA s4
 4AB  14500                                     SLA s5
 4AC  14600                                     SLA s6
 4AD  14700                                     SLA s7
 4AE  14800                                     SLA s8
 4AF  0380F                                     AND s8, 0F                                     ; Zero the unused nibble
 4B0  0D808                                     TEST s8, 08                                    ; if bit 106 is 1 then shiftsignificand to left by 1
 4B1  324BC                                     JUMP Z, 4BC[dont_inc_exponent]                 ; and increment the exponent
 4B2                                            ; shift significand left by 1
 4B2  14206                                     SL0 s2
 4B3  14300                                     SLA s3
 4B4  14400                                     SLA s4
 4B5  14500                                     SLA s5
 4B6  14600                                     SLA s6
 4B7  14700                                     SLA s7
 4B8  14800                                     SLA s8
 4B9  0380F                                     AND s8, 0F                                     ; Zero the unused nibble
 4BA                                            ; add 1 to exponent
 4BA  11001                                     ADD s0, 01
 4BB  13100                                     ADDCY s1, 00
 4BC                         dont_inc_exponent: 
 4BC                                            ; Shift the exponent result to left by 4 bit.
 4BC  14006                                     SL0 s0
 4BD  14100                                     SLA s1
 4BE  14000                                     SLA s0
 4BF  14100                                     SLA s1
 4C0  14000                                     SLA s0
 4C1  14100                                     SLA s1
 4C2  14000                                     SLA s0
 4C3  14100                                     SLA s1
 4C4  030F0                                     AND s0, F0
 4C5                                            ; Combine exponent and significand
 4C5  04800                                     OR s8, s0
 4C6                                            ; Calculate the sign
 4C6  0BF18                                     FETCH sF, 18[x_sign]
 4C7  0BE23                                     FETCH sE, 23[y_sign]
 4C8  06FE0                                     XOR sF, sE                                     ; Calculate the sign
 4C9  03F80                                     AND sF, 80
 4CA  041F0                                     OR s1, sF                                      ; Apply the sign
 4CB                                            ; Save the result in SMP
 4CB  2F217                                     STORE s2, 17[r_0]
 4CC  2F316                                     STORE s3, 16[r_1]
 4CD  2F415                                     STORE s4, 15[r_2]
 4CE  2F514                                     STORE s5, 14[r_3]
 4CF  2F613                                     STORE s6, 13[r_4]
 4D0  2F712                                     STORE s7, 12[r_5]
 4D1  2F811                                     STORE s8, 11[r_6]
 4D2  2F110                                     STORE s1, 10[r_7]
 4D3                        mul_result_is_zero: 
 4D3  205B3                                     CALL 5B3[return_zero_mul]
 4D4                          done_multiplying: 
 4D4  25000                                     RETURN 
 4D5                                            ;------------------------------------------------------------------------------------
 4D5                                            ; Procedure:   mul_mx_my()
 4D5                                            ;
 4D5                                            ; Registers Used: Bank0 : All
 4D5                                            ;     Bank1 : None
 4D5                                            ;
 4D5                                            ; Arguments:   Bank0 : None
 4D5                                            ;     Bank1 : None
 4D5                                            ;     SPM   : x_m6, x_m5, ... x_m0 (7-bytes)
 4D5                                            ;       y_m6, y_m5, ... y_m0  (7-bytes)
 4D5                                            ;
 4D5                                            ;
 4D5                                            ; Calls:
 4D5                                            ;
 4D5                                            ; RETs:    Bank1:
 4D5                                            ;
 4D5                                            ; RETURN Flags:   None
 4D5                                            ;
 4D5                                            ; Description:  Multiplies two 53-bit double-precision floating point numbers.
 4D5                                            ;------------------------------------------------------------------------------------
 4D5                                 mul_mx_my: 
 4D5                                            ; Setup shifted mx SPM
 4D5  01D00                                     LOAD sD, 00
 4D6  01C00                                     LOAD sC, 00
 4D7  01B00                                     LOAD sB, 00
 4D8  01A00                                     LOAD sA, 00
 4D9  01900                                     LOAD s9, 00
 4DA  01800                                     LOAD s8, 00
 4DB  01700                                     LOAD s7, 00
 4DC  0B61B                                     FETCH s6, 1B[x_m6]
 4DD  0B51C                                     FETCH s5, 1C[x_m5]
 4DE  0B41D                                     FETCH s4, 1D[x_m4]
 4DF  0B31E                                     FETCH s3, 1E[x_m3]
 4E0  0B21F                                     FETCH s2, 1F[x_m2]
 4E1  0B120                                     FETCH s1, 20[x_m1]
 4E2  0B021                                     FETCH s0, 21[x_m0]
 4E3  2FD50                                     STORE sD, 50[Umx_shifted_6]
 4E4  2FC51                                     STORE sC, 51[Umx_shifted_5]
 4E5  2FB52                                     STORE sB, 52[Umx_shifted_4]
 4E6  2FA53                                     STORE sA, 53[Umx_shifted_3]
 4E7  2F954                                     STORE s9, 54[Umx_shifted_2]
 4E8  2F855                                     STORE s8, 55[Umx_shifted_1]
 4E9  2F756                                     STORE s7, 56[Umx_shifted_0]
 4EA  2F657                                     STORE s6, 57[Lmx_shifted_6]
 4EB  2F558                                     STORE s5, 58[Lmx_shifted_5]
 4EC  2F459                                     STORE s4, 59[Lmx_shifted_4]
 4ED  2F35A                                     STORE s3, 5A[Lmx_shifted_3]
 4EE  2F25B                                     STORE s2, 5B[Lmx_shifted_2]
 4EF  2F15C                                     STORE s1, 5C[Lmx_shifted_1]
 4F0  2F05D                                     STORE s0, 5D[Lmx_shifted_0]
 4F1  01F00                                     LOAD sF, 00                                    ; Initially shift to left by 0
 4F2  01E00                                     LOAD sE, 00                                    ; Initially shift to left by 0
 4F3                                            ; TEST s0, 01    ; Test if bit 0 is one
 4F3                                            ; JUMP  NZ, shifting_mx_left_done
 4F3                            next_shift_add: 
 4F3                                            ; load my
 4F3  0B626                                     FETCH s6, 26[y_m6]
 4F4  0B527                                     FETCH s5, 27[y_m5]
 4F5  0B428                                     FETCH s4, 28[y_m4]
 4F6  0B329                                     FETCH s3, 29[y_m3]
 4F7  0B22A                                     FETCH s2, 2A[y_m2]
 4F8  0B12B                                     FETCH s1, 2B[y_m1]
 4F9  0B02C                                     FETCH s0, 2C[y_m0]
 4FA                          next_right_shift: 
 4FA  1DF35                                     COMPARE sF, 35                                 ; Have reached 54?
 4FB  32586                                     JUMP Z, 586[finish_mul]                        ; Yes: Finish the multiplication
 4FC  0D001                                     TEST s0, 01                                    ; Check the LSB
 4FD  36508                                     JUMP NZ, 508[shift_and_add]                    ; if it is 1: shift and add
 4FE                                            ; it is 0: shift my to right by 1
 4FE  1460E                                     SR0 s6
 4FF  14508                                     SRA s5
 500  14408                                     SRA s4
 501  14308                                     SRA s3
 502  14208                                     SRA s2
 503  14108                                     SRA s1
 504  14008                                     SRA s0
 505  11E01                                     ADD sE, 01
 506  11F01                                     ADD sF, 01
 507  224FA                                     JUMP 4FA[next_right_shift]
 508                             shift_and_add: 
 508                                            ; Save shifted my into SPM
 508  2F626                                     STORE s6, 26[y_m6]
 509  2F527                                     STORE s5, 27[y_m5]
 50A  2F428                                     STORE s4, 28[y_m4]
 50B  2F329                                     STORE s3, 29[y_m3]
 50C  2F22A                                     STORE s2, 2A[y_m2]
 50D  2F12B                                     STORE s1, 2B[y_m1]
 50E  2F02C                                     STORE s0, 2C[y_m0]
 50F                                            ; load mx
 50F  0BD50                                     FETCH sD, 50[Umx_shifted_6]
 510  0BC51                                     FETCH sC, 51[Umx_shifted_5]
 511  0BB52                                     FETCH sB, 52[Umx_shifted_4]
 512  0BA53                                     FETCH sA, 53[Umx_shifted_3]
 513  0B954                                     FETCH s9, 54[Umx_shifted_2]
 514  0B855                                     FETCH s8, 55[Umx_shifted_1]
 515  0B756                                     FETCH s7, 56[Umx_shifted_0]
 516  0B657                                     FETCH s6, 57[Lmx_shifted_6]
 517  0B558                                     FETCH s5, 58[Lmx_shifted_5]
 518  0B459                                     FETCH s4, 59[Lmx_shifted_4]
 519  0B35A                                     FETCH s3, 5A[Lmx_shifted_3]
 51A  0B25B                                     FETCH s2, 5B[Lmx_shifted_2]
 51B  0B15C                                     FETCH s1, 5C[Lmx_shifted_1]
 51C  0B05D                                     FETCH s0, 5D[Lmx_shifted_0]
 51D  1DE00                                     COMPARE sE, 00
 51E  3253D                                     JUMP Z, 53D[shifting_mx_left_done2]
 51F                                            ; Shift mx left by sE
 51F                     keep_shifting_mx_left: 
 51F  14006                                     SL0 s0
 520  14100                                     SLA s1
 521  14200                                     SLA s2
 522  14300                                     SLA s3
 523  14400                                     SLA s4
 524  14500                                     SLA s5
 525  14600                                     SLA s6
 526  14700                                     SLA s7
 527  14800                                     SLA s8
 528  14900                                     SLA s9
 529  14A00                                     SLA sA
 52A  14B00                                     SLA sB
 52B  14C00                                     SLA sC
 52C  14D00                                     SLA sD
 52D  19E01                                     SUB sE, 01
 52E  3651F                                     JUMP NZ, 51F[keep_shifting_mx_left]
 52F                     shifting_mx_left_done: 
 52F  2FD50                                     STORE sD, 50[Umx_shifted_6]
 530  2FC51                                     STORE sC, 51[Umx_shifted_5]
 531  2FB52                                     STORE sB, 52[Umx_shifted_4]
 532  2FA53                                     STORE sA, 53[Umx_shifted_3]
 533  2F954                                     STORE s9, 54[Umx_shifted_2]
 534  2F855                                     STORE s8, 55[Umx_shifted_1]
 535  2F756                                     STORE s7, 56[Umx_shifted_0]
 536  2F657                                     STORE s6, 57[Lmx_shifted_6]
 537  2F558                                     STORE s5, 58[Lmx_shifted_5]
 538  2F459                                     STORE s4, 59[Lmx_shifted_4]
 539  2F35A                                     STORE s3, 5A[Lmx_shifted_3]
 53A  2F25B                                     STORE s2, 5B[Lmx_shifted_2]
 53B  2F15C                                     STORE s1, 5C[Lmx_shifted_1]
 53C  2F05D                                     STORE s0, 5D[Lmx_shifted_0]
 53D                    shifting_mx_left_done2: 
 53D                                            ; now add shifted mx to the previous result (mr)
 53D                                            ; Load lower half of mr into registers [sD, s7]
 53D  0BD47                                     FETCH sD, 47[Lmr_6]
 53E  0BC48                                     FETCH sC, 48[Lmr_5]
 53F  0BB49                                     FETCH sB, 49[Lmr_4]
 540  0BA4A                                     FETCH sA, 4A[Lmr_3]
 541  0B94B                                     FETCH s9, 4B[Lmr_2]
 542  0B84C                                     FETCH s8, 4C[Lmr_1]
 543  0B74D                                     FETCH s7, 4D[Lmr_0]
 544                                            ; Load lower half of shifted mx into registers [s6, s0] :already there
 544                                            ; Add
 544  10070                                     ADD s0, s7
 545  12180                                     ADDCY s1, s8
 546  12290                                     ADDCY s2, s9
 547  123A0                                     ADDCY s3, sA
 548  124B0                                     ADDCY s4, sB
 549  125C0                                     ADDCY s5, sC
 54A  126D0                                     ADDCY s6, sD
 54B                                            ; save result
 54B  2F647                                     STORE s6, 47[Lmr_6]
 54C  2F548                                     STORE s5, 48[Lmr_5]
 54D  2F449                                     STORE s4, 49[Lmr_4]
 54E  2F34A                                     STORE s3, 4A[Lmr_3]
 54F  2F24B                                     STORE s2, 4B[Lmr_2]
 550  2F14C                                     STORE s1, 4C[Lmr_1]
 551  2F04D                                     STORE s0, 4D[Lmr_0]
 552                                            ; JUMP NC, no_carry_for_lower_add
 552                                            ; save the carry
 552                                            ; LOAD  s7, 01
 552                                            ; STORE s7, mr_save_carry
 552                                            ;no_carry_for_lower_add:
 552                                            ; Load upper half of mr into registers [sD, s7]
 552  0BD40                                     FETCH sD, 40[Umr_6]
 553  0BC41                                     FETCH sC, 41[Umr_5]
 554  0BB42                                     FETCH sB, 42[Umr_4]
 555  0BA43                                     FETCH sA, 43[Umr_3]
 556  0B944                                     FETCH s9, 44[Umr_2]
 557  0B845                                     FETCH s8, 45[Umr_1]
 558  0B746                                     FETCH s7, 46[Umr_0]
 559                                            ; Load upper half of shifted mx into registers [s6, s0]
 559  0B650                                     FETCH s6, 50[Umx_shifted_6]
 55A  0B551                                     FETCH s5, 51[Umx_shifted_5]
 55B  0B452                                     FETCH s4, 52[Umx_shifted_4]
 55C  0B353                                     FETCH s3, 53[Umx_shifted_3]
 55D  0B254                                     FETCH s2, 54[Umx_shifted_2]
 55E  0B155                                     FETCH s1, 55[Umx_shifted_1]
 55F  0B056                                     FETCH s0, 56[Umx_shifted_0]
 560                                            ; Add
 560  12070                                     ADDCY s0, s7
 561  12180                                     ADDCY s1, s8
 562  12290                                     ADDCY s2, s9
 563  123A0                                     ADDCY s3, sA
 564  124B0                                     ADDCY s4, sB
 565  125C0                                     ADDCY s5, sC
 566  126D0                                     ADDCY s6, sD
 567                                            ; save result
 567  2F640                                     STORE s6, 40[Umr_6]
 568  2F541                                     STORE s5, 41[Umr_5]
 569  2F442                                     STORE s4, 42[Umr_4]
 56A  2F343                                     STORE s3, 43[Umr_3]
 56B  2F244                                     STORE s2, 44[Umr_2]
 56C  2F145                                     STORE s1, 45[Umr_1]
 56D  2F046                                     STORE s0, 46[Umr_0]
 56E                                            ;shift my to right by 1 so we can check its LSB in next round
 56E                                            ; load my
 56E  0B626                                     FETCH s6, 26[y_m6]
 56F  0B527                                     FETCH s5, 27[y_m5]
 570  0B428                                     FETCH s4, 28[y_m4]
 571  0B329                                     FETCH s3, 29[y_m3]
 572  0B22A                                     FETCH s2, 2A[y_m2]
 573  0B12B                                     FETCH s1, 2B[y_m1]
 574  0B02C                                     FETCH s0, 2C[y_m0]
 575  1460E                                     SR0 s6
 576  14508                                     SRA s5
 577  14408                                     SRA s4
 578  14308                                     SRA s3
 579  14208                                     SRA s2
 57A  14108                                     SRA s1
 57B  14008                                     SRA s0
 57C  2F626                                     STORE s6, 26[y_m6]
 57D  2F527                                     STORE s5, 27[y_m5]
 57E  2F428                                     STORE s4, 28[y_m4]
 57F  2F329                                     STORE s3, 29[y_m3]
 580  2F22A                                     STORE s2, 2A[y_m2]
 581  2F12B                                     STORE s1, 2B[y_m1]
 582  2F02C                                     STORE s0, 2C[y_m0]
 583  11F01                                     ADD sF, 01
 584  01E01                                     LOAD sE, 01                                    ; tracks the numebr of shifts per round, set it to zero for next round
 585  224F3                                     JUMP 4F3[next_shift_add]
 586                                finish_mul: 
 586  25000                                     RETURN 
 587                                            ;------------------------------------------------------------------------------------
 587                                            ; Procedure:   add_ex_ey()
 587                                            ;
 587                                            ; Registers Used: Bank0 : All
 587                                            ;     Bank1 : None
 587                                            ;
 587                                            ; Arguments:   Bank0 : None
 587                                            ;     Bank1 : None
 587                                            ;     SPM   : x_m6, x_m5, ... x_m0 (7-bytes)
 587                                            ;       y_m6, y_m5, ... y_m0  (7-bytes)
 587                                            ;
 587                                            ;
 587                                            ; Calls:
 587                                            ;
 587                                            ; RETs:    Bank1: [s1. s0]
 587                                            ;
 587                                            ; RETURN Flags:   None
 587                                            ;
 587                                            ; Description:  Calculates the ex + ey which is Ex + Ey - bias(1023) and returns
 587                                            ;      the result in [s1, s0].
 587                                            ;------------------------------------------------------------------------------------
 587                                 add_ex_ey: 
 587  0B119                                     FETCH s1, 19[x_ex7]
 588  0B01A                                     FETCH s0, 1A[x_ex6]
 589  0B324                                     FETCH s3, 24[y_ex7]
 58A  0B225                                     FETCH s2, 25[y_ex6]
 58B  10020                                     ADD s0, s2
 58C  12130                                     ADDCY s1, s3
 58D  190FF                                     SUB s0, FF                                     ; subtract by 1023'd =  03FF
 58E  1B103                                     SUBCY s1, 03
 58F  25000                                     RETURN 
 590                                            ;------------------------------------------------------------------------------------
 590                                            ; Procedure:   mul_special_cases()
 590                                            ;
 590                                            ; Registers Used: Bank0 : s1, s2
 590                                            ;     Bank1 : None
 590                                            ;
 590                                            ; Arguments:   Bank0 : None
 590                                            ;     Bank1 : None
 590                                            ;
 590                                            ;
 590                                            ; Calls:
 590                                            ;
 590                                            ; RETs:    Bank1: [s1. s0]
 590                                            ;
 590                                            ; RETURN Flags:   None
 590                                            ;
 590                                            ; Description:  Takes care of special operands in multiplication.
 590                                            ;     Return FF in sF if one of the operands is special.
 590                                            ;     If sF is FF then the result is already in [r_7, r_8] in SPM.
 590                                            ;------------------------------------------------------------------------------------
 590                         mul_special_cases: 
 590  0B13A                                     FETCH s1, 3A[op1_status]                       ; read the ops status
 591  0B23B                                     FETCH s2, 3B[op2_status]                       ; read the ops status
 592                                            ; We check op1 for
 592                                            ; 1) NaN
 592                                            ;  Yes: return X_NaN
 592                                            ;  No:  Go to step 2.
 592                                            ; 2) Infinity
 592                                            ;  Yes: Check op2, if +0 and NaN then return_NaN_Inf
 592                                            ;  No:  return +infinity
 592                                            ; 3) Zero
 592                                            ;  Yes: check if op2 is +inf or NaN then return_NaN_Inf
 592                                            ;     else return 0
 592                                            ;  No:  check op2
 592                                            ;-----------------------------------------------
 592                                            ; Check if op1 is NaN
 592  0D110                                     TEST s1, 10
 593  32595                                     JUMP Z, 595[mul_final_op1_not_NaN]             ; No
 594                         mul_final_op1_NaN: ; Yes
 594                                            ; Check if op2 is NaN
 594                                            ;TEST s2, 10
 594                                            ;JUMP  NZ, return_NAN   ; Yes
 594  22177                                     JUMP 177[return_x_NAN]
 595                     mul_final_op1_not_NaN: 
 595                                            ; +inf + + inf = +inf
 595                                            ; +inf + - inf = +NaN
 595                                            ; -inf + + inf = +NaN
 595                                            ; -inf + - inf = -inf
 595                                            ; infinity sign is the AND of both operands' sign bits.
 595                                            ; Result NaN bit is XOR of both operands' sign bits.
 595                                            ;-----------------------------------
 595                                            ; Check if op1 is Inf
 595  0D120                                     TEST s1, 20
 596  3259C                                     JUMP Z, 59C[mul_final_op1_not_Inf]             ; No
 597                         mul_final_op1_Inf: ; Yes
 597                                            ; Check if op2 is Inf
 597  0D220                                     TEST s2, 20
 598  361CF                                     JUMP NZ, 1CF[return_y_NAN_Inf]                 ; Yes
 599                                            ; Check if op2 is NaN
 599  0D210                                     TEST s2, 10
 59A  361BC                                     JUMP NZ, 1BC[return_y_NAN]                     ; Yes
 59B  2218A                                     JUMP 18A[return_x_NAN_Inf]
 59C                     mul_final_op1_not_Inf: 
 59C                                            ; Check if op1 is zero
 59C  0D140                                     TEST s1, 40
 59D  325A3                                     JUMP Z, 5A3[mul_check_final_op2]               ; No
 59E                     mul_final_op1_is_zero: 
 59E                                            ; Check if op2 is Inifinity
 59E  0D220                                     TEST s2, 20
 59F  365A6                                     JUMP NZ, 5A6[return_y_NAN_positive]            ; Yes
 5A0                                            ; Check if op2 is NaN
 5A0  0D210                                     TEST s2, 10
 5A1  365A6                                     JUMP NZ, 5A6[return_y_NAN_positive]            ;Yes
 5A2  225B3                                     JUMP 5B3[return_zero_mul]
 5A3                                            ; Op1 is not NaN, Inf, and zero, so we conclude op1 is (sub)normal.
 5A3                                            ; We check op2 for
 5A3                                            ; 1) NaN
 5A3                                            ;  Yes: return_NaN_Inf
 5A3                                            ;  No:  Go to step 2.
 5A3                                            ; 2) Infinity
 5A3                                            ;  Yes: return_NaN_Inf
 5A3                                            ;  No:  return x
 5A3                                            ; 3) Zero
 5A3                                            ;  Yes: return zero
 5A3                                            ;  No:  swap_step
 5A3                       mul_check_final_op2: 
 5A3                                            ; Check if op2 is NaN
 5A3  0D210                                     TEST s2, 10
 5A4  365A6                                     JUMP NZ, 5A6[return_y_NAN_positive]            ;Yes
 5A5  225AB                                     JUMP 5AB[mul_final_op2_not_NaN]
 5A6                     return_y_NAN_positive: 
 5A6                                            ; make y positive
 5A6  01E7F                                     LOAD sE, 7F
 5A7  0BD08                                     FETCH sD, 08[y_7]
 5A8  02DE0                                     AND sD, sE
 5A9  2FD08                                     STORE sD, 08[y_7]
 5AA  221BC                                     JUMP 1BC[return_y_NAN]
 5AB                     mul_final_op2_not_NaN: ; No
 5AB                                            ; +inf + + inf = +inf
 5AB                                            ; +inf + - inf = +NaN
 5AB                                            ; -inf + + inf = +NaN
 5AB                                            ; -inf + - inf = -inf
 5AB                                            ; infinity sign is the AND of both operands' sign bits.
 5AB                                            ; Result NaN bit is XOR of both operands' sign bits.
 5AB                                            ; Check if op2 is NaN
 5AB  0D210                                     TEST s2, 10
 5AC  361BC                                     JUMP NZ, 1BC[return_y_NAN]                     ; Yes
 5AD                     mul_final_op2_not_Inf: ; No
 5AD                                            ; Check if op2 is infinity
 5AD  0D220                                     TEST s2, 20
 5AE  361CF                                     JUMP NZ, 1CF[return_y_NAN_Inf]                 ; Yes
 5AF                                            ; Check if op2 is zero
 5AF  0D240                                     TEST s2, 40
 5B0  365B3                                     JUMP NZ, 5B3[return_zero_mul]                  ; Yes
 5B1                                            ; Both operators are (sub)normal. Perform the multiplication.
 5B1  01F00                                     LOAD sF, 00
 5B2  25000                                     RETURN 
 5B3                                            ;------------------------------------------------------------------------------------
 5B3                                            ; Procedure:   return_zero_mul()
 5B3                                            ;
 5B3                                            ; Registers Used: Bank0 :
 5B3                                            ;     Bank1 : None
 5B3                                            ;
 5B3                                            ; Arguments:   Bank0 :
 5B3                                            ;     Bank1 : None
 5B3                                            ;
 5B3                                            ; Calls:    None
 5B3                                            ;     None
 5B3                                            ;
 5B3                                            ; RETs:
 5B3                                            ;
 5B3                                            ; RETURN Flags:   None
 5B3                                            ;
 5B3                                            ; Description:  Returns zero
 5B3                                            ;------------------------------------------------------------------------------------
 5B3                           return_zero_mul: 
 5B3  01FFF                                     LOAD sF, FF
 5B4                                            ; +0 +0 => +0
 5B4                                            ; -0 +0 => -0
 5B4                                            ; +0 -0 => -0
 5B4                                            ; -0 -0 => +0
 5B4  0B118                                     FETCH s1, 18[x_sign]
 5B5  0B223                                     FETCH s2, 23[y_sign]
 5B6  06120                                     XOR s1, s2                                     ; Calculate the sign of zero
 5B7  03180                                     AND s1, 80                                     ; zero all other bits except sign
 5B8  01000                                     LOAD s0, 00
 5B9  2F011                                     STORE s0, 11[r_6]
 5BA  2F012                                     STORE s0, 12[r_5]
 5BB  2F013                                     STORE s0, 13[r_4]
 5BC  2F014                                     STORE s0, 14[r_3]
 5BD  2F015                                     STORE s0, 15[r_2]
 5BE  2F016                                     STORE s0, 16[r_1]
 5BF  2F017                                     STORE s0, 17[r_0]
 5C0  2F110                                     STORE s1, 10[r_7]
 5C1  25000                                     RETURN 
 5C2                                            ;------------------------------------------------------------------------------------
 5C2                                            ; Procedure:   mul_cancellation()
 5C2                                            ;
 5C2                                            ; Registers Used: Bank0 : [s6, s0]
 5C2                                            ;     Bank1 : None
 5C2                                            ;
 5C2                                            ; Arguments:   Bank0 :
 5C2                                            ;     Bank1 : None
 5C2                                            ;
 5C2                                            ; Calls:    None
 5C2                                            ;     None
 5C2                                            ;
 5C2                                            ; RETs:    sA : the number of bits shifted to left
 5C2                                            ;
 5C2                                            ; RETURN Flags:   None
 5C2                                            ;
 5C2                                            ; Description:  Receives a subnormal significand in [s6, s0] and normalizes it
 5C2                                            ;------------------------------------------------------------------------------------
 5C2                          mul_cancellation: 
 5C2                                            ; Count the number of leading zeros = nlz
 5C2                                            ; Shift left by nlz, and rturn the number of shifted bits.
 5C2                                            ; Check if er is zero then the result is as it is
 5C2  01A01                                     LOAD sA, 01                                    ; nlz nounter
 5C3  00860                                     LOAD s8, s6                                    ; make a copy of s6
 5C4  14807                                     SL1 s8
 5C5  14807                                     SL1 s8
 5C6  14807                                     SL1 s8
 5C7  14807                                     SL1 s8
 5C8                                            ; Count nlz in s8
 5C8  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 5C9  0D9FF                                     TEST s9, FF                                    ; is s9 = 0 ?
 5CA  325F6                                     JUMP Z, 5F6[mul_nlz_counting_done]
 5CB  1D904                                     COMPARE s9, 04
 5CC  325CF                                     JUMP Z, 5CF[mul_got_nlz_4]
 5CD  10A90                                     ADD sA, s9                                     ; Less than 4 zeros, Add the counted nlz to sA
 5CE                                            ;  and finish the nlz counting,
 5CE  225F6                                     JUMP 5F6[mul_nlz_counting_done]
 5CF                             mul_got_nlz_4: 
 5CF  11A04                                     ADD sA, 04                                     ; Add 4 nlz to sA
 5D0  00850                                     LOAD s8, s5
 5D1  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 5D2  1D908                                     COMPARE s9, 08
 5D3  325D6                                     JUMP Z, 5D6[mul_got_nlz_8]
 5D4  10A90                                     ADD sA, s9                                     ; Less than 8 zeros, Add the counted nlz to sA
 5D5                                            ;  and finish the nlz counting,
 5D5  225F6                                     JUMP 5F6[mul_nlz_counting_done]
 5D6                             mul_got_nlz_8: 
 5D6  11A08                                     ADD sA, 08                                     ; Add 8 nlz to sA
 5D7  00840                                     LOAD s8, s4
 5D8  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 5D9  1D908                                     COMPARE s9, 08
 5DA  325DD                                     JUMP Z, 5DD[mul_got_nlz_8_s3]
 5DB  10A90                                     ADD sA, s9                                     ; Less than 4 zeros, Add the counted nlz to sA
 5DC                                            ;  and finish the nlz counting,
 5DC  225F6                                     JUMP 5F6[mul_nlz_counting_done]
 5DD                          mul_got_nlz_8_s3: 
 5DD  11A08                                     ADD sA, 08                                     ; Add 8 nlz to sA
 5DE  00830                                     LOAD s8, s3
 5DF  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 5E0  1D908                                     COMPARE s9, 08
 5E1  325E4                                     JUMP Z, 5E4[mul_got_nlz_8_s2]
 5E2  10A90                                     ADD sA, s9                                     ; Less than 8 zeros, Add the counted nlz to sA
 5E3                                            ;  and finish the nlz counting,
 5E3  225F6                                     JUMP 5F6[mul_nlz_counting_done]
 5E4                          mul_got_nlz_8_s2: 
 5E4  11A08                                     ADD sA, 08                                     ; Add 8 nlz to sA
 5E5  00820                                     LOAD s8, s2
 5E6  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 5E7  1D908                                     COMPARE s9, 08
 5E8  325EB                                     JUMP Z, 5EB[mul_got_nlz_8_s1]
 5E9  10A90                                     ADD sA, s9                                     ; Less than 8 zeros, Add the counted nlz to sA
 5EA                                            ;  and finish the nlz counting,
 5EA  225F6                                     JUMP 5F6[mul_nlz_counting_done]
 5EB                          mul_got_nlz_8_s1: 
 5EB  11A08                                     ADD sA, 08                                     ; Add 8 nlz to sA
 5EC  00810                                     LOAD s8, s1
 5ED  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 5EE  1D908                                     COMPARE s9, 08
 5EF  325F2                                     JUMP Z, 5F2[mul_got_nlz_8_s0]
 5F0  10A90                                     ADD sA, s9                                     ; Less than 8 zeros, Add the counted nlz to sA
 5F1                                            ;  and finish the nlz counting,
 5F1  225F6                                     JUMP 5F6[mul_nlz_counting_done]
 5F2                          mul_got_nlz_8_s0: 
 5F2  11A08                                     ADD sA, 08                                     ; Add 8 nlz to sA
 5F3  00800                                     LOAD s8, s0
 5F4  202DD                                     CALL 2DD[count_nlz]                            ; RETs number of zeros in s9
 5F5  10A90                                     ADD sA, s9                                     ; Less than 8 zeros, Add the counted nlz to sA
 5F6                                            ;  and finish the nlz counting,
 5F6                     mul_nlz_counting_done: 
 5F6                                            ; Shift the significand to left by nlz(sA) bits.
 5F6  009A0                                     LOAD s9, sA                                    ; Copy the sA
 5F7                                            ; At this point result mantisa is in [s7, s6, ..., s1]
 5F7          mul_intermediate_shift_riht_loop: 
 5F7  14006                                     SL0 s0                                         ; 1-bit left shift
 5F8  14100                                     SLA s1
 5F9  14200                                     SLA s2
 5FA  14300                                     SLA s3
 5FB  14400                                     SLA s4
 5FC  14500                                     SLA s5
 5FD  14600                                     SLA s6
 5FE  14700                                     SLA s7
 5FF  19901                                     SUB s9, 01
 600  365F7                                     JUMP NZ, 5F7[mul_intermediate_shift_riht_loop]
 601  25000                                     RETURN 
 602                          mul_normalize_mx: 
 602                                            ; Load mx into registers
 602  0B61B                                     FETCH s6, 1B[x_m6]
 603                                            ; Check if the significant is already normalized or not
 603  0D610                                     TEST s6, 10
 604  36612                                     JUMP NZ, 612[already_normalized]
 605                                            ; Significand is not normalized so normalize it.
 605                                            ; Continue loading mx into registers
 605  0B51C                                     FETCH s5, 1C[x_m5]
 606  0B41D                                     FETCH s4, 1D[x_m4]
 607  0B31E                                     FETCH s3, 1E[x_m3]
 608  0B21F                                     FETCH s2, 1F[x_m2]
 609  0B120                                     FETCH s1, 20[x_m1]
 60A  0B021                                     FETCH s0, 21[x_m0]
 60B  205C2                                     CALL 5C2[mul_cancellation]                     ; return sA = number of bits shifted to left
 60C                                            ; Subtract exponent by sA
 60C  0BE1A                                     FETCH sE, 1A[x_ex6]
 60D  0BF19                                     FETCH sF, 19[x_ex7]
 60E  18EA0                                     SUB sE, sA
 60F  1BF00                                     SUBCY sF, 00
 610  2FE1A                                     STORE sE, 1A[x_ex6]
 611  2FF19                                     STORE sF, 19[x_ex7]
 612                        already_normalized: 
 612  25000                                     RETURN 
 613                          mul_normalize_my: 
 613                                            ; Load mx into registers
 613  0B626                                     FETCH s6, 26[y_m6]
 614                                            ; Check if the significant is already normalized or not
 614  0D610                                     TEST s6, 10
 615  36623                                     JUMP NZ, 623[already_normalized_y]
 616                                            ; Significand is not normalized so normalize it.
 616                                            ; Continue loading mx into registers
 616  0B527                                     FETCH s5, 27[y_m5]
 617  0B428                                     FETCH s4, 28[y_m4]
 618  0B329                                     FETCH s3, 29[y_m3]
 619  0B22A                                     FETCH s2, 2A[y_m2]
 61A  0B12B                                     FETCH s1, 2B[y_m1]
 61B  0B02C                                     FETCH s0, 2C[y_m0]
 61C  205C2                                     CALL 5C2[mul_cancellation]                     ; return sA = number of bits shifted to left
 61D                                            ; Subtract exponent by sA
 61D  0BE25                                     FETCH sE, 25[y_ex6]
 61E  0BF24                                     FETCH sF, 24[y_ex7]
 61F  18EA0                                     SUB sE, sA
 620  1BF00                                     SUBCY sF, 00
 621  2FE25                                     STORE sE, 25[y_ex6]
 622  2FF24                                     STORE sF, 24[y_ex7]
 623                      already_normalized_y: 
 623  25000                                     RETURN 


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

D:\workspace\Vivado_2018.3\zcu104\fft2\fft2.srcs\sources_1\imports\sources_1\original.psm



List of defined constants

 CONSTANT name              Value        Source PSM File

 timestamp_hours            00'd         
 timestamp_minutes          24'd         
 timestamp_seconds          57'd         
 datestamp_year             19'd         
 datestamp_month            2'd          
 datestamp_day              14'd         
 NUL                        00           
 BEL                        07           
 BS                         08           
 HT                         09           
 LF                         0A           
 VT                         0B           
 CR                         0D           
 ESC                        1B           
 DEL                        7F           
 DCS                        90           
 ST                         9C           
 UART_Tx_data_present       00000001'b   original.psm
 UART_Tx_half_full          00000010'b   original.psm
 UART_Tx_full               00000100'b   original.psm
 UART_Rx_data_present       00001000'b   original.psm
 UART_Rx_half_full          00010000'b   original.psm
 UART_Rx_full               00100000'b   original.psm
 UART_RX6_status_input_port 00           original.psm
 UART_RX6_data_input_port   01           original.psm
 Extra_mem_input_port       02           original.psm
 UART_TX6_output_port       00           original.psm
 Extra_mem_lo_output_port   01           original.psm
 Extra_mem_hi_output_port   02           original.psm
 Extra_mem_output_port      03           original.psm
 irqs_output_port           04           original.psm
 reset_UART_port            01           original.psm
 UART_tx_reset              00000001'b   original.psm
 UART_rx_reset              00000010'b   original.psm
 UART_reset                 00000011'b   original.psm
 UART_operate               00000000'b   original.psm
 x_7                        0'd          original.psm
 x_6                        1'd          original.psm
 x_5                        2'd          original.psm
 x_4                        3'd          original.psm
 x_3                        4'd          original.psm
 x_2                        5'd          original.psm
 x_1                        6'd          original.psm
 x_0                        7'd          original.psm
 y_7                        8'd          original.psm
 y_6                        9'd          original.psm
 y_5                        10'd         original.psm
 y_4                        11'd         original.psm
 y_3                        12'd         original.psm
 y_2                        13'd         original.psm
 y_1                        14'd         original.psm
 y_0                        15'd         original.psm
 r_7                        16'd         original.psm
 r_6                        17'd         original.psm
 r_5                        18'd         original.psm
 r_4                        19'd         original.psm
 r_3                        20'd         original.psm
 r_2                        21'd         original.psm
 r_1                        22'd         original.psm
 r_0                        23'd         original.psm
 x_sign                     24'd         original.psm
 x_ex7                      25'd         original.psm
 x_ex6                      26'd         original.psm
 x_m6                       27'd         original.psm
 x_m5                       28'd         original.psm
 x_m4                       29'd         original.psm
 x_m3                       30'd         original.psm
 x_m2                       31'd         original.psm
 x_m1                       32'd         original.psm
 x_m0                       33'd         original.psm
 x_grs                      34'd         original.psm
 y_sign                     35'd         original.psm
 y_ex7                      36'd         original.psm
 y_ex6                      37'd         original.psm
 y_m6                       38'd         original.psm
 y_m5                       39'd         original.psm
 y_m4                       40'd         original.psm
 y_m3                       41'd         original.psm
 y_m2                       42'd         original.psm
 y_m1                       43'd         original.psm
 y_m0                       44'd         original.psm
 y_grs                      45'd         original.psm
 r_sign                     46'd         original.psm
 r_ex7                      47'd         original.psm
 r_ex6                      48'd         original.psm
 r_m6                       49'd         original.psm
 r_m5                       50'd         original.psm
 r_m4                       51'd         original.psm
 r_m3                       52'd         original.psm
 r_m2                       53'd         original.psm
 r_m1                       55'd         original.psm
 r_m0                       56'd         original.psm
 r_grs                      57'd         original.psm
 op1_status                 58'd         original.psm
 op2_status                 59'd         original.psm
 underflow                  60'd         original.psm
 IEEE_754_DP_signals        61'd         original.psm
 Umr_6                      64'd         original.psm
 Umr_5                      65'd         original.psm
 Umr_4                      66'd         original.psm
 Umr_3                      67'd         original.psm
 Umr_2                      68'd         original.psm
 Umr_1                      69'd         original.psm
 Umr_0                      70'd         original.psm
 Lmr_6                      71'd         original.psm
 Lmr_5                      72'd         original.psm
 Lmr_4                      73'd         original.psm
 Lmr_3                      74'd         original.psm
 Lmr_2                      75'd         original.psm
 Lmr_1                      76'd         original.psm
 Lmr_0                      77'd         original.psm
 mr_save_carry              78'd         original.psm
 Umx_shifted_6              80'd         original.psm
 Umx_shifted_5              81'd         original.psm
 Umx_shifted_4              82'd         original.psm
 Umx_shifted_3              83'd         original.psm
 Umx_shifted_2              84'd         original.psm
 Umx_shifted_1              85'd         original.psm
 Umx_shifted_0              86'd         original.psm
 Lmx_shifted_6              87'd         original.psm
 Lmx_shifted_5              88'd         original.psm
 Lmx_shifted_4              89'd         original.psm
 Lmx_shifted_3              90'd         original.psm
 Lmx_shifted_2              91'd         original.psm
 Lmx_shifted_1              92'd         original.psm
 Lmx_shifted_0              93'd         original.psm



No TABLEs defined



List of text strings

 STRING name       String                                Source PSM File

 KCPSM6_version$   "v2.70"                               
 datestamp$        "14 Feb 2019"                         
 timestamp$        "00:24:57"                            
 welcome$          "Welcome to KCPSM6 !!! (Debug Mode)"  original.psm



List of line labels

   Label                               Addr  Source PSM File

   start                               004   original.psm
   finished_calculation                03A   original.psm
   debug_mode                          03B   original.psm
   print_two_operands                  042   original.psm
   wait_for_start                      04C   original.psm
   welcome_msg                         053   original.psm
   UART_TX                             078   original.psm
   UART_TX_delay                       07E   original.psm
   UART_RX                             082   original.psm
   rx_timeout                          083   original.psm
   read_Rx                             089   original.psm
   reset_UART_macros                   08B   original.psm
 * delay_1ms                           08E   original.psm
   delay_1ms_loop                      090   original.psm
   send_CRLF                           094   original.psm
   send_message                        099   original.psm
   clear_screen                        0A0   original.psm
 * reg_print_hex                       0AF   original.psm
   less_or_eq_to_nine3                 0B7   original.psm
   greater_than_nine3                  0B9   original.psm
   done_adding3                        0BA   original.psm
   less_or_eq_to_nine4                 0BF   original.psm
   greater_than_nine4                  0C1   original.psm
   done_adding4                        0C2   original.psm
   SPM_print_hex                       0C5   original.psm
   print_hex_loop                      0C6   original.psm
   less_or_eq_to_nine                  0CF   original.psm
   greater_than_nine                   0D1   original.psm
   done_adding                         0D2   original.psm
   less_or_eq_to_nine2                 0D7   original.psm
   greater_than_nine2                  0D9   original.psm
   done_adding2                        0DA   original.psm
 * done_printing_one_hex               0DC   original.psm
 * add_dp                              0E2   original.psm
   load_8Bytes_from_ext_BRAM           0E3   original.psm
   read_8bytes_ext_BRAM_loop           0E5   original.psm
   Read_ext_mem                        0ED   original.psm
   Write_ext_mem                       0F5   original.psm
   invoke_done_interrupt               0FD   original.psm
   delay_int_loop                      103   original.psm
   write_result_to_external_memory     108   original.psm
 * arith_add_x_y                       129   original.psm
 * final_op1_NaN                       130   original.psm
   return_NAN                          133   original.psm
   final_op1_not_NaN                   13A   original.psm
 * final_op1_Inf                       13C   original.psm
   final_op1_not_Inf                   141   original.psm
 * final_op1_is_zero                   143   original.psm
   check_final_op2                     148   original.psm
 * final_op2_not_NaN                   14A   original.psm
 * final_op2_not_Inf                   153   original.psm
   return_zero                         156   original.psm
   return_x                            165   original.psm
   return_x_NAN                        177   original.psm
   return_x_NAN_Inf                    18A   original.psm
   NaN_bit_off                         196   original.psm
   done_applying_NaN_bit               197   original.psm
   return_y                            1AA   original.psm
   return_y_NAN                        1BC   original.psm
   return_y_NAN_Inf                    1CF   original.psm
 * set_sign_bit_to_0                   1DA   original.psm
   set_sign_bit_to_1                   1DC   original.psm
   set_sign_bit_done                   1DD   original.psm
 * set_NaN_bit_to_0                    1E0   original.psm
   set_NaN_bit_to_1                    1E2   original.psm
   set_NaN_bit_done                    1E3   original.psm
   COMP_swap_ex                        1F2   original.psm
 * ex_greater_equal_than_ey            1F9   original.psm
 * ex_equal_ey                         1FA   original.psm
   ex_less_than_ey                     206   original.psm
   swap_done                           207   original.psm
   op1_is_normal_nx_is_1               214   original.psm
   op2_is_normal_ny_is_1               219   original.psm
   not_a_big_shift                     221   original.psm
   my_mantisa_shift_right_loop         22D   original.psm
   dont_set_sticky_bit_y               239   original.psm
   my_mantisa_shift_right_loop_done    23C   original.psm
   my_mantisa_shift_right_done         247   original.psm
   sx_is_neg_sy_is_pos                 252   original.psm
   sx_is_positive                      257   original.psm
   sx_sy_is_positive                   25F   original.psm
   perform_addition                    263   original.psm
   dont_apply_twos                     280   original.psm
   sign_calc_done                      282   original.psm
   load_mx                             29E   original.psm
   load_my                             2A7   original.psm
   swap_operands                       2B0   original.psm
   count_nlz                           2DD   original.psm
   count_mlz_loop                      2DE   original.psm
   counting_z_done                     2E2   original.psm
   round                               2E3   original.psm
   guard_bit_is_1                      2E6   original.psm
   round_bit_is_0                      2E9   original.psm
   round_RET_one                       2ED   original.psm
   round_RET_zero                      2F0   original.psm
   apply_rounding                      2F2   original.psm
   decompose_x                         2FA   original.psm
   negative_sign_x                     2FF   original.psm
   test_x_sign_done                    300   original.psm
   subnormal_involved_x                312   original.psm
   subnormal_test_done_x               313   original.psm
   decompose_y                         324   original.psm
 * positive_sign_y                     327   original.psm
   negative_sign_y                     329   original.psm
   test_y_sign_done                    32A   original.psm
   subnormal_involved_y                33C   original.psm
   subnormal_test_done_y               33D   original.psm
   set_ops_status                      34E   original.psm
 * ex_zero                             354   original.psm
 * op_1_is_zero                        36B   original.psm
   op1_is_subnormal                    36F   original.psm
   ex_not_zero                         373   original.psm
 * ex_all_one                          37A   original.psm
 * op1_is_NaN                          389   original.psm
   op1_is_inf                          38D   original.psm
   ex_not_all_one                      391   original.psm
   set_op2_status                      394   original.psm
 * ey_zero                             39A   original.psm
 * op_2_is_zero                        3A9   original.psm
   op2_is_subnormal                    3AD   original.psm
   ey_not_zero                         3B1   original.psm
 * ey_all_one                          3B8   original.psm
 * op2_is_NaN                          3C7   original.psm
   op2_is_inf                          3CB   original.psm
   ey_not_all_one                      3CF   original.psm
   twos_mx                             3D3   original.psm
   twos_my                             3ED   original.psm
   normalize                           407   original.psm
   dont_keep_sticky_bit                40D   original.psm
   done_keeping_sticky_bit             40E   original.psm
   no_overflow_found                   41E   original.psm
 * check_subnormal_case                420   original.psm
   cancellation                        431   original.psm
   got_nlz_4                           444   original.psm
   got_nlz_8                           44B   original.psm
   got_nlz_8_s5                        452   original.psm
   got_nlz_8_s4                        459   original.psm
   got_nlz_8_s3                        460   original.psm
   got_nlz_8_s2                        467   original.psm
   nlz_counting_done                   46B   original.psm
   intermediate_shift_riht_loop        46E   original.psm
   done_intermediate_shift_riht_loop   478   original.psm
 * normalize_shift_right_by_one        47F   original.psm
   done_cancellation                   48D   original.psm
   arith_mul_x_y                       48E   original.psm
   dont_inc_exponent                   4BC   original.psm
   mul_result_is_zero                  4D3   original.psm
   done_multiplying                    4D4   original.psm
   mul_mx_my                           4D5   original.psm
   next_shift_add                      4F3   original.psm
   next_right_shift                    4FA   original.psm
   shift_and_add                       508   original.psm
   keep_shifting_mx_left               51F   original.psm
 * shifting_mx_left_done               52F   original.psm
   shifting_mx_left_done2              53D   original.psm
   finish_mul                          586   original.psm
   add_ex_ey                           587   original.psm
   mul_special_cases                   590   original.psm
 * mul_final_op1_NaN                   594   original.psm
   mul_final_op1_not_NaN               595   original.psm
 * mul_final_op1_Inf                   597   original.psm
   mul_final_op1_not_Inf               59C   original.psm
 * mul_final_op1_is_zero               59E   original.psm
   mul_check_final_op2                 5A3   original.psm
   return_y_NAN_positive               5A6   original.psm
   mul_final_op2_not_NaN               5AB   original.psm
 * mul_final_op2_not_Inf               5AD   original.psm
   return_zero_mul                     5B3   original.psm
   mul_cancellation                    5C2   original.psm
   mul_got_nlz_4                       5CF   original.psm
   mul_got_nlz_8                       5D6   original.psm
   mul_got_nlz_8_s3                    5DD   original.psm
   mul_got_nlz_8_s2                    5E4   original.psm
   mul_got_nlz_8_s1                    5EB   original.psm
   mul_got_nlz_8_s0                    5F2   original.psm
   mul_nlz_counting_done               5F6   original.psm
   mul_intermediate_shift_riht_loop    5F7   original.psm
   mul_normalize_mx                    602   original.psm
   already_normalized                  612   original.psm
   mul_normalize_my                    613   original.psm
   already_normalized_y                623   original.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            123
 STAR              -

 AND              34
 OR               29
 XOR              28

 ADD              56
 ADDCY            56
 SUB              15
 SUBCY             9

 TEST             66
 TESTCY           27
 COMPARE          28
 COMPARECY        10

 SL0               8
 SL1               9
 SLX               -
 SLA              66
 RL                -
 SR0              26
 SR1               -
 SRX               -
 SRA              52
 RR                -

 REGBANK           4

 INPUT             4
 OUTPUT           11
 OUTPUTK           2

 STORE           292
 FETCH           292

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP            168
 JUMP@             -
 CALL             92
 CALL@             1
 RETURN           48
 LOAD&RETURN      37

 HWBUILD           -



End of KCPSM6 log file.
